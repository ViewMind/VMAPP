const Utils = require('./report_utils');

class FourPointGraph {

   // Parameters.
   #pdf
   #configuration

   // Computed values. 
   #vertical_scale_m
   #vertical_scale_b
   #vertical_max_value
   #x_pos_left_value_line
   #x_pos_right_value_line
   #axis_line_width
   #dot_radious
   #dash_length
   #y_top_graph
   #y_bottom_graph
   #x_graph
   #graph_width
   #ymax;

   // Constants
   #W_SPACE_FOR_YLABEL      = 0.08 // % of the bb.w 
   #H_SPACE_FOR_LABELS      = 0.05 // % of the bb.h
   #AXIS_LINE_WIDTH         = 0.003 // % of the bb.h
   #MAX_VALUE_OVERSHOOT     = 1.1  // This is how much over the max value is represented in the ceiling of the graph. 
   #NUMBER_OF_YVALUE_LABELS = 3;
   #Y_VALUE_FONT_SIZE       = 7;
   #MARGIN_Y_VALUE          = 0.01 // % of the Graph effective width. 
   #MARGIN_FOR_VALUE_LINE   = 0.25 // % of the Graph effective width. 
   #RADIOUS_RATIO           = 0.015 // % of the Graph effective width. 
   #DASH_LENGTH_RATIO       = 0.005 // % of the Graph effective width. 
   #LABEL_FONT_SIZE         = 8;
   #TITLE_SCALE             = 1.2; // Multiplier of Label Font Size.
   #LEGEND_SCALE            = 1.0; // Multiplier of Label Font Size.

   /**
    * Creates a graph where variance line as drawn against two pair of points. Each pair of points has the same x value. 
    * Assumes always that the x axis is at zero. 
    * @param {jsPDF instance} pdf 
    * @param {Object} [config] - Values and text required for the graph. 
    * @param {Object} [config.boundingRect] - The bounding rect in which the entire graph has to fit (minus the legend). 
    * @param {number} [config.boundingRect.x] - The x coordinate of the top left of the bounding rect. 
    * @param {number} [config.boundingRect.y] - The y coordinate of the top left of the bounding rect. 
    * @param {number} [config.boundingRect.w] - The width of the bounding rect. 
    * @param {number} [config.boundingRect.h] - The height of the bounding rect. 
    * @param {boolean} [config.legend] - If true the legend is outputted. Otherwise it's not.
    * @param {string} [config.leftColumnText]  - The text on x-axis, left hand side. 
    * @param {string} [config.rightColumnText] - The text on x-axis, right hand side.
    * @param {string} [config.yLabel] - Text on the y axis (will be vertically oriented)
    * @param {string} [config.title] - Optional. If present it will written centered, above the graph. 
    * @param {string} [config.yUnits] - Units for the value on the y Axis. 
    * @param {string} [config.legendValueType0] - Each dot in the pair is set to one color. This is the string legend that correponds to the first do on each set
    * @param {string} [config.legendValueType1] - Each dot in the pair is set to one color. This is the string legend that correponds to the second do on each set
    * @param {Array}  [config.leftSet] - Array of two objects representing the value and the variance of each value drawn in the left hand side. Each object has is an Object with the parameters "value" and "variance"
    * @param {Array}  [config.rightSet] - Array of two objects representing the value and the variance of each value drawn in the right hand side. "value" and "variance"
    * @param {Array}  [config.ndecimals] - Optional. If present it, these are the number of decimals that will be used in the y labels. 
    * @param {boolean}[config.dbug] - Optional. If exists and it is true it draws a background over the entire area. 
    * @param {Array}  [config.ymax] - Optional. If present this value will be used to compute the scale instead of the value coputed via the sets. 
    * @param {boolean}[config.hideyticks] - Optional. If present and true the text on the horizontal lines of the grid for the y values will not be drawn. 
    */

   constructor(pdf,config){
      this.#pdf = pdf;
      this.#configuration = config;
   }

   render(){

      // For Debugging Only. We add a Gray Area to the background. 
      if ("dbug" in this.#configuration){
         if (this.#configuration.dbug){
            this.#pdf.setFillColor("#dddddd");
            this.#pdf.setDrawColor("#dddddd");
            this.#pdf.rect(this.#configuration.boundingRect.x,this.#configuration.boundingRect.y, this.#configuration.boundingRect.w, this.#configuration.boundingRect.h,"F");
         }
      }

      // Drawing the background
      this.renderBackgroud();

      // Doing the actual plotting
      this.plotSet(0,Utils.Colors.GRAPH_BLUE);
      this.plotSet(1,Utils.Colors.GRAPH_PURPLE);

      // Writing all of the graph text.
      this.renderGraphLabels();

      // Writing the legend.
      if (this.#configuration.legend){
         this.renderSideLegends();
      }

   }

   /**
    * Auxiliary function that allows rendering the legend, centered below two graphs. Needs to be called after render(). 
    * @param {number} totalWidth - The combined width used by this graph and the second one. 
    */

   renderCenteredLegedBelowGraph(totalWidth){

      this.#pdf.setFont("Montserrat","Regular")
      this.#pdf.setFontSize(this.#LABEL_FONT_SIZE*this.#LEGEND_SCALE);

      var dim_set_0 = this.#pdf.getTextDimensions(this.#configuration.legendValueType0);
      var dim_set_1 = this.#pdf.getTextDimensions(this.#configuration.legendValueType1);

      // The space between the two strings will be 3 radious diameters.
      var space_between = 3*2*this.#dot_radious;
      var space_between_circle_and_legend = 3*this.#dot_radious; 
      var total_occupied_width = dim_set_0.w + space_between + dim_set_1.w + 4*this.#dot_radious + 2*space_between_circle_and_legend;
      var xoffset = this.#x_graph + (totalWidth - total_occupied_width)/2;
      var y = this.#configuration.boundingRect.y + this.#configuration.boundingRect.h;
      var circley = y + (dim_set_0.h - this.#dot_radious*2) + this.#dot_radious + 0.5*dim_set_0.h; // Centering the circle vertically with the center of the text.   
      y = y + 1.5*dim_set_0.h;  // The text y is that of the botom line so we have to add the margin we want (1/2 a line height) + the actual height of the text. 
      var x = xoffset + 2*this.#dot_radious + space_between_circle_and_legend
      var circlex = xoffset + this.#dot_radious;

      // The 0 set legend.
      this.#pdf.setTextColor(Utils.Colors.GRAPH_BLUE)
      this.#pdf.setFillColor(Utils.Colors.GRAPH_BLUE)

      this.#pdf.text(x,y,this.#configuration.legendValueType0)
      this.#pdf.circle(circlex,circley,this.#dot_radious,"F")

      // The 1 set legend.
      this.#pdf.setTextColor(Utils.Colors.GRAPH_PURPLE)
      this.#pdf.setFillColor(Utils.Colors.GRAPH_PURPLE)      
      circlex = xoffset + space_between_circle_and_legend + dim_set_0.w + space_between + 2*this.#dot_radious;
      this.#pdf.circle(circlex,circley,this.#dot_radious,"F")
      x = x + space_between + dim_set_0.w + space_between_circle_and_legend + 2*this.#dot_radious
      this.#pdf.text(x,y,this.#configuration.legendValueType1)

   }

   renderBackgroud(){

      // Drawing the background
      var vertical_space_for_labels = this.#configuration.boundingRect.h*2*this.#H_SPACE_FOR_LABELS;
      //var horizontal_space_for_y_labels = this.#configuration.boundingRect.w*this.#W_SPACE_FOR_YLABEL;
      var ymargin_top = 0;
      var xmargin_left = 0;
      if ("title" in this.#configuration){
         ymargin_top = vertical_space_for_labels;
         vertical_space_for_labels = vertical_space_for_labels*2;         
      }
      if ("yLabel" in this.#configuration ){
         xmargin_left = this.#configuration.boundingRect.w*this.#W_SPACE_FOR_YLABEL;
         //horizontal_space_for_y_labels = this.#configuration.boundingRect.w*this.#W_SPACE_FOR_YLABEL;
      }

      var x = this.#configuration.boundingRect.x + xmargin_left
      var y = this.#configuration.boundingRect.y + ymargin_top
      var w = this.#configuration.boundingRect.w - xmargin_left;
      var h = this.#configuration.boundingRect.h - vertical_space_for_labels;

      this.#pdf.setFillColor(Utils.Colors.GRAPH_BACKGROUND);
      this.#pdf.rect(x,y,w,h,"F")

      // Line and grid size widths.
      var axisLineW = this.#AXIS_LINE_WIDTH*this.#configuration.boundingRect.h      
      this.#pdf.setLineWidth(axisLineW);

      // Values required for other functions
      this.#axis_line_width = axisLineW;
      this.#dot_radious     = this.#RADIOUS_RATIO * w;
      this.#dash_length     = this.#DASH_LENGTH_RATIO * w;
      this.#y_top_graph     = y;
      this.#y_bottom_graph  = y + h;
      this.#x_graph         = x;
      this.#graph_width     = w;

      // Computing the scale constants and the maximum value. 
      this.computeMaxValue(y,y+h);

      // There is always 3 numbers in the y scale. 
      var n = this.#NUMBER_OF_YVALUE_LABELS+1;
      var scale_interval = this.#vertical_max_value/n
      var vertical_displacement_interval = h/n;

      // Drawing the grid.
      this.#pdf.setDrawColor(Utils.Colors.WHITE);
      //this.#pdf.setDrawColor("#ff0000");
      this.#pdf.setLineWidth(axisLineW);
      for (var i = 1; i < n; i++) {
         var y_pos = y + h - vertical_displacement_interval*i;         
         this.#pdf.line(x,y_pos+axisLineW,x+w,y_pos+axisLineW,"S");
      }

      // Adding the vertical lines.
      this.#x_pos_left_value_line = x + w*this.#MARGIN_FOR_VALUE_LINE
      this.#pdf.line(this.#x_pos_left_value_line,y,this.#x_pos_left_value_line,y+h,"S")
      
      this.#x_pos_right_value_line = x+w - w*this.#MARGIN_FOR_VALUE_LINE
      this.#pdf.line(this.#x_pos_right_value_line,y,this.#x_pos_right_value_line,y+h,"S")

      // Drawing the X Axis. 
      this.#pdf.setDrawColor(Utils.Colors.MAIN_BLUE);
      this.#pdf.line(x,y+h-axisLineW,x+w,y+h-axisLineW,"S");

      // Drawing the Y values, only if not hidden. 
      if ("hideyticks" in this.#configuration){
         if (this.#configuration.hideyticks) return;
      }

      this.#pdf.setFont("Montserrat","ExtraLight")
      this.#pdf.setFontSize(this.#Y_VALUE_FONT_SIZE);
      this.#pdf.setTextColor(Utils.Colors.DARK_TEXT_COLOR);
      
      for (var i = 1; i < n; i++) {
         
         var display_value
         if ("ndecimals" in this.#configuration){
            display_value = scale_interval*i
            display_value = display_value.toFixed(scale_interval*i)
            display_value = display_value + this.#configuration.yUnits;
         }
         else{
            display_value = Math.round(scale_interval*i) + this.#configuration.yUnits;
         }
         
         var y_pos = y + h - vertical_displacement_interval*i;
         
         //var dim = this.#pdf.getTextDimensions(display_value);
         //var text_y_pos = y_pos
         this.#pdf.text(display_value,x + w*this.#MARGIN_Y_VALUE,y_pos,{"baseline":"bottom"})
      }
      
   }

   plotSet(set,color){
      
      this.#pdf.setLineWidth(this.#axis_line_width)
      this.#pdf.setDrawColor(color);
      this.#pdf.setFillColor(color);

      var yvalue, yplus, yminus;

      // Left Side. 
      yvalue  = this.getYValue(this.#configuration.leftSet[set].value)
      yplus   = this.getYValue(this.#configuration.leftSet[set].value + this.#configuration.leftSet[set].variance)
      yminus  = this.getYValue(this.#configuration.leftSet[set].value - this.#configuration.leftSet[set].variance)

      // Adding the variance line
      this.#pdf.line(this.#x_pos_left_value_line,yminus,this.#x_pos_left_value_line,yplus,"S");

      // Adding the actual circle. 
      this.#pdf.circle(this.#x_pos_left_value_line,yvalue,this.#dot_radious,"F");
      var leftyval = yvalue;

      // Right Side. 
      yvalue  = this.getYValue(this.#configuration.rightSet[set].value)
      yplus   = this.getYValue(this.#configuration.rightSet[set].value + this.#configuration.rightSet[set].variance)
      yminus  = this.getYValue(this.#configuration.rightSet[set].value - this.#configuration.rightSet[set].variance)

      // Adding the variance line
      this.#pdf.line(this.#x_pos_right_value_line,yminus,this.#x_pos_right_value_line,yplus,"S");

      // Adding the actual circle. 
      this.#pdf.circle(this.#x_pos_right_value_line,yvalue,this.#dot_radious,"F");

      // Adding the dashed line.
      this.#pdf.setLineWidth(this.#axis_line_width/2)
      this.#pdf.setLineDashPattern([this.#dash_length, this.#dash_length*0.75],0);
      this.#pdf.line(this.#x_pos_left_value_line,leftyval,this.#x_pos_right_value_line,yvalue);
      this.#pdf.setLineDashPattern(); // This removes the dash line pattern. 

   }

   renderGraphLabels(){

      // Rendering the y axis label.
      this.#pdf.setFont("Montserrat","Regular")
      this.#pdf.setFontSize(this.#LABEL_FONT_SIZE);
      this.#pdf.setTextColor(Utils.Colors.DARK_TEXT_COLOR);

      var h, dim, x, y

      if ("yLabel" in this.#configuration){
         h = this.#y_bottom_graph - this.#y_top_graph; // The actual graph height. 
         dim = this.#pdf.getTextDimensions(this.#configuration.yLabel);
   
         // Computing the y position so that the rotated text is centered on the graph. 
         y = this.#y_top_graph + h - (h - dim.w)/2
   
         x = this.#x_graph - dim.h; // We use half the text height as a margin between the label and the graph.       
   
         //this.#pdf.text(this.#configuration.yLabel,x,y);
         this.#pdf.text(this.#configuration.yLabel,x,y,{angle: 90, rotationDirection: 1});
         //this.#pdf.circle(x,y,this.#dot_radious,"F")
      }

      // Rendering the lables in the y axis. 
      dim = this.#pdf.getTextDimensions(this.#configuration.leftColumnText);
      x = this.#x_pos_left_value_line - dim.w/2;
      y = this.#y_bottom_graph + dim.h*1.5; // We use half the text height as a margin from the bottom.
      this.#pdf.text(this.#configuration.leftColumnText,x,y);

      dim = this.#pdf.getTextDimensions(this.#configuration.rightColumnText);
      x = this.#x_pos_right_value_line - dim.w/2;
      this.#pdf.text(this.#configuration.rightColumnText,x,y);

      if ("title" in this.#configuration){
         this.#pdf.setFont("Montserrat","Medium")
         this.#pdf.setTextColor(Utils.Colors.MAIN_BLUE);
         this.#pdf.setFontSize(this.#LABEL_FONT_SIZE*this.#TITLE_SCALE)
         dim = this.#pdf.getTextDimensions(this.#configuration.title);
         x = this.#x_graph + (this.#graph_width - dim.w)/2
         y = this.#y_top_graph - dim.h/2 // We use half the text height as a margin from the top.
         this.#pdf.text(this.#configuration.title,x,y);
      }

   }

   renderSideLegends(){

      this.#pdf.setFont("Montserrat","Regular")
      this.#pdf.setFontSize(this.#LABEL_FONT_SIZE*this.#LEGEND_SCALE);

      var dim_set_0 = this.#pdf.getTextDimensions(this.#configuration.legendValueType0);
      var dim_set_1 = this.#pdf.getTextDimensions(this.#configuration.legendValueType1);

      var total_height = dim_set_0.h*2 + dim_set_1.h // It's multiplied times to because we want to leave the height of an entire line between both legend values.
      var graph_h = this.#y_bottom_graph - this.#y_top_graph; // The actual graph height. 
      var y = this.#y_top_graph + (graph_h - total_height)/2;
      var x = this.#x_graph + this.#graph_width + this.#dot_radious*8
      var circley = y + (dim_set_0.h - this.#dot_radious*2) + this.#dot_radious; // Centering the circle vertically with the center of the text. 
      var circlex  = x - 4*this.#dot_radious

      this.#pdf.setTextColor(Utils.Colors.GRAPH_BLUE)
      this.#pdf.setFillColor(Utils.Colors.GRAPH_BLUE)
      this.#pdf.text(x,y+dim_set_0.h,this.#configuration.legendValueType0)
      this.#pdf.circle(circlex,circley,this.#dot_radious,"F")
      
      this.#pdf.setTextColor(Utils.Colors.GRAPH_PURPLE)
      this.#pdf.setFillColor(Utils.Colors.GRAPH_PURPLE)
      this.#pdf.text(x,y+dim_set_0.h*2+dim_set_1.h,this.#configuration.legendValueType1)
      circley = circley + dim_set_0.h*2
      this.#pdf.circle(circlex,circley,this.#dot_radious,"F")

   }

   getYMax(){
      return this.#ymax;
   }

   computeMaxValue(maxy, miny){

      var max = 0;

      if ("ymax" in this.#configuration){
         max = this.#configuration.ymax;
      }
      else{
         var values = [];
         values.push(this.#configuration.leftSet[0].value + this.#configuration.leftSet[0].variance)
         values.push(this.#configuration.leftSet[1].value + this.#configuration.leftSet[1].variance)
         values.push(this.#configuration.rightSet[0].value + this.#configuration.rightSet[0].variance)
         values.push(this.#configuration.rightSet[1].value + this.#configuration.rightSet[1].variance)
   
         
         for (var i = 0; i < values.length; i++){
            if (max < values[i]) max = values[i];
         }
      }
      
      this.#ymax = max;
      this.#vertical_max_value = max*this.#MAX_VALUE_OVERSHOOT;
      this.#vertical_scale_m   = (maxy - miny)/this.#vertical_max_value
      this.#vertical_scale_b   = miny

   }

   getYValue(v){
      return this.#vertical_scale_b + this.#vertical_scale_m*v;
   }


}

module.exports = FourPointGraph