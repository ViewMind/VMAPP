const Utils = require("./report_utils")
const Spline = require("./spline")

class SmoothLineGraph {

   // Construction parametes.
   #pdf
   #x_ticks
   #y_ticks
   #x_graph
   #y_graph
   #y_end_x_ticks
   #graph_width
   #graph_height
   #datasets
   #x_map
   #y_map

   // Constants.
   #LEFT_MARGIN_FOR_Y_LABEL = 0.06  // % of bb.w
   #BOTTOM_MARGIN_FOR_TEXT  = 0.12  // % of bb.h
   #VALUE_MARGIN_PERCENT    = 0.6   // % of the effective scale range.
   #AXIS_WIDTH              = 0.006 // % of graph.h
   #PLOT_LINE_WIDTH         = 0.004 // % of graph.h
   #LEFT_MARGIN_Y_TICKS     = 0.01  //% of graph width
   #FONT_Y_LABEL = 10
   #FONT_X_TICK = 8;
   #FONT_Y_TICK = 6
  
   // Computed values. 

   // Config parameters.   
   constructor(pdf){
      this.#pdf = pdf;
   }

   /**
    * Renders a multi line graph given the configuration. Connections between points can be smoothed out. 
    * @param {Object} [config] Configuration of the graph and values to be actually used. 
    * @param {number} [config.boundingBox.w] Width of the entire graph bounding box. 
    * @param {number} [config.boundingBox.h] Height of the entire graph bounding box. 
    * @param {number} [config.boundingBox.x] x coordinate of the entire graph bounding box
    * @param {number} [config.boundingBox.y] y coordinate of the entire graph bounding box. 
    * @param {Array}  [config.dataSets] - A list of the datasets that will be graphed. Each dataset is also an Array composed of two valued arrays (x,y)
    * @param {Array} [config.legend] - Am array of objects the same size as config.dataSets. Each item is an Object of the form {color: a_color, text: "Label text"}. This defins the color and legend text for each data set. 
    * @param {number} [config.numberOfXTicks] - The number of x ticks that should appear in the x axis.
    * @param {number} [config.numberOfYTicks] - The number of y tick labels that should appear in the y axis.
    * @param {string} [config.ylabel] - The vertical text of the y axis
    * @param {string} [config.xlabel] - The text for the x axis. 
    * @param {number} [config.xdecimals] - Number of decimals to use in xlabels (0 means use int values)
    * @param {boolean} [config.enableGrid] - If true, grid is drawn, otherwise it's not. 
    * @param {number} [config.nspline] - The number of points to use for the cubic spline to smooth between two points. 
    */

   render(config){

      //this.#pdf.setDrawColor("aaaaaa")
      //this.#pdf.rect(config.boundingBox.x,config.boundingBox.y, config.boundingBox.w, config.boundingBox.h, "S")

      this.#x_graph = config.boundingBox.x + config.boundingBox.w*this.#LEFT_MARGIN_FOR_Y_LABEL
      this.#y_graph = config.boundingBox.y;
      this.#graph_width = config.boundingBox.w*(1-this.#LEFT_MARGIN_FOR_Y_LABEL);
      this.#graph_height = config.boundingBox.h*(1-this.#BOTTOM_MARGIN_FOR_TEXT);

      this.#datasets = config.dataSets;

      //console.log(config.dataSets)

      this.computeScaleTransformation(config.numberOfXTicks,config.numberOfYTicks);

      this.renderGraphBackground(config.xdecimals, config.enableGrid);

      this.renderLabelsAndLegends(config.ylabel, config.xlabel, config.legend);

      this.plot(config.legend,config.nspline)

   }


   plot(legend,nspline){

      this.#pdf.setLineWidth(this.#graph_height*this.#PLOT_LINE_WIDTH);

      for (var d = 0; d < legend.length; d++){

         var color = legend[d].color;
         this.#pdf.setDrawColor(color);
         this.#pdf.setFillColor(color);
         this.#pdf.setLineJoin("circle");

         var toplot = [];
         if (nspline > 0){
            const spline = new Spline(nspline);
            toplot = spline.interpolate(this.#datasets[d])
            //console.log(toplot.length);
         }
         else{
            toplot = this.#datasets[d];
         }

         var path = [];
         for (var i = 0; i < toplot.length; i++){
            var point = toplot[i]
            var x = this.#x_map.getMappedValue(point[0])
            var y = this.#y_map.getMappedValue(point[1])
            var temp = {};
            temp.op = "l";
            if (i == 0) temp.op = "m";
            temp.c = [x, y];
            path.push(temp);
         }

         this.#pdf.path(path);
         this.#pdf.stroke();

      }

   }

   renderGraphBackground(xdecimals, grid_on){


      // Graph background
      this.#pdf.setFillColor(Utils.Colors.GRAPH_BACKGROUND);
      this.#pdf.rect(this.#x_graph,this.#y_graph,this.#graph_width,this.#graph_height,"F");

      // X axis. 
      var lwidth = this.#graph_height*this.#AXIS_WIDTH
      this.#pdf.setDrawColor(Utils.Colors.MAIN_BLUE)
      this.#pdf.setLineWidth(lwidth);
      var y = this.#y_graph + this.#graph_height - lwidth/2;
      this.#pdf.line(this.#x_graph,y,this.#x_graph + this.#graph_width,y,"S");

      this.#pdf.setFont("Montserrat","Light")
      this.#pdf.setTextColor(Utils.Colors.LINEGRAPH_AXIS_LABEL)
      this.#pdf.setFontSize(this.#FONT_X_TICK);

      // For the lines
      this.#pdf.setDrawColor(Utils.Colors.WHITE)

      // Printing the X ticks.
      y = this.#y_graph + this.#graph_height;
      for (var i = 0; i < this.#x_ticks.length; i++){
         //console.log(this.#x_ticks[i])

         var dispx;
         if (xdecimals == 0)dispx = parseInt(this.#x_ticks[i]);
         dispx = parseFloat(this.#x_ticks[i]).toFixed(xdecimals);
                  
         var xpos = this.#x_map.getMappedValue(dispx);
         //console.log(xpos)
         var bb = this.#pdf.getTextDimensions(dispx);

         // Computing this for later on. 
         this.#y_end_x_ticks = y + bb.h/2 + bb.h;

         var xgrid = xpos;
         var xpos = xpos - bb.w/2;
         //console.log(dispx,xpos,y+bb.h/2);
         this.#pdf.text(dispx,xpos,y+bb.h/2,{baseline: "top"});

         // Adding the gridline.
         if (grid_on) this.#pdf.line(xgrid,this.#y_graph,xgrid,this.#y_graph + this.#graph_height - lwidth,"S")
         
      }

      // Printing the Y ticks.
      this.#pdf.setFontSize(this.#FONT_Y_TICK);
      var x = this.#x_graph + this.#graph_width*this.#LEFT_MARGIN_Y_TICKS;
      for (var i = 0; i < this.#y_ticks.length; i++){
         
         var dispy = parseFloat(this.#y_ticks[i]).toFixed(1);
         //console.log(dispy)
         var ypos = this.#y_map.getMappedValue(dispy);
         //ypos = this.#y_graph;
         var bb = this.#pdf.getTextDimensions(dispy);
         this.#pdf.text(dispy,x,ypos,{baseline: "bottom"});

         // Adding the horizontal gridlines. 
         if (grid_on) this.#pdf.line(this.#x_graph,ypos,this.#x_graph + this.#graph_width,ypos,"S")
      }

   }

   renderLabelsAndLegends(ylabel, xlabel, legend){

      // Rendering the y axis label.
      this.#pdf.setFont("Montserrat","Regular")
      this.#pdf.setFontSize(this.#FONT_Y_LABEL);
      this.#pdf.setTextColor(Utils.Colors.DARK_TEXT_COLOR);

      var dim, x, y

      dim = this.#pdf.getTextDimensions(ylabel);
   
      // Computing the y position so that the rotated text is centered on the graph. 
      y = this.#y_graph + this.#graph_height - (this.#graph_height - dim.w)/2
      x = this.#x_graph - dim.h; 
   
      this.#pdf.text(ylabel,x,y,{angle: 90, rotationDirection: 1});

      // Rendering the x axis label.
      this.#pdf.setFontSize(this.#FONT_X_TICK);
      dim = this.#pdf.getTextDimensions(xlabel);
      x = this.#x_graph + (this.#graph_width - dim.w)/2;
      y = this.#y_end_x_ticks + dim.h;
      this.#pdf.text(xlabel,x,y,{baseline: "top"})
      y = y + dim.h*2; // Added twice, once for the actual height and another to give that much space. 

      // Rendering the legends. We first need to know the complete text width. 
      var totalWidth = 0;
      var legendH = 0;
      var nD = legend.length; // Number of datasets, and hence, of legends.
      this.#pdf.setFontSize(this.#FONT_Y_LABEL);
      for (var i = 0; i < legend.length; i++){
         var dim = this.#pdf.getTextDimensions(legend[i].text);
         totalWidth = totalWidth + dim.w;
         if (dim.h > legendH) legendH = dim.h;
      }
      var R = legendH/2; // Radious for the dot. 
      var space_between_dot_text = 2*R
      var space_between_legend = 6*R;
      totalWidth = totalWidth 
      + nD*2*R // Each legend will have a dot.
      + nD*space_between_dot_text // And will have this space between the dot and the text
      + (nD-1)*space_between_legend // The space between each legend will be reapeated the number of legends minus 1. 
      x = this.#x_graph + (this.#graph_width - totalWidth)/2;

      for (var i = 0; i < legend.length; i++){
         this.#pdf.setTextColor(legend[i].color);
         this.#pdf.setFillColor(legend[i].color)
         var dim = this.#pdf.getTextDimensions(legend[i].text);
         var cx = x + R;
         var cy = y + R;
         this.#pdf.circle(cx,cy,R,"F");
         x = x + 2*R+space_between_dot_text
         this.#pdf.text(legend[i].text,x,y,{baseline: "top"});
         x = x + dim.w + space_between_legend;
      }

   }

   computeScaleTransformation(nx_ticks, ny_ticks){

      var max_y
      var min_y
      var max_x
      var min_x

      //console.log(this.#datasets);

      for (var i = 0; i < this.#datasets.length; i++){
         for (var j = 0; j < this.#datasets[i].length; j++){
            if ((i == 0) && (j == 0)){
               //console.log("puto");
               max_y = this.#datasets[i][j][1]
               min_y = this.#datasets[i][j][1]
               max_x = this.#datasets[i][j][0]
               min_x = this.#datasets[i][j][0]
               //console.log(this.#datasets[i][j])
               //console.log(min_y,min_x,max_x,max_y)
            }
            else{
               if (max_y < this.#datasets[i][j][1]) max_y = this.#datasets[i][j][1];
               else if (min_y > this.#datasets[i][j][1]) min_y = this.#datasets[i][j][1];
               if (max_x < this.#datasets[i][j][0]) max_x = this.#datasets[i][j][0];
               else if (min_x > this.#datasets[i][j][0]) min_x = this.#datasets[i][j][0];
            }
            //console.log(min_y,min_x,max_x,max_y)
         }
         //console.log(min_y,min_x,max_x,max_y)
      }

      // To set up the margins wee need margin_perecet% more over the max and below the min. Only for the y values. 
      var scale_range = max_y - min_y;
      var overscale = scale_range*this.#VALUE_MARGIN_PERCENT;
      max_y = max_y + overscale;
      min_y = min_y - overscale;
      // var overmult = 1 + this.#VALUE_MARGIN_PERCENT;
      // var undermult = 1 - this.#VALUE_MARGIN_PERCENT;

      // if (max_y > 0)  max_y = max_y*overmult;
      // else max_y = max_y*undermult
      // console.log(min_y)
      // if (min_y > 0 ) min_y = min_y*undermult;
      // else min_y = min_y*overmult;
      // console.log(min_y)

      // Creating the linear map for the values. 
      this.#y_map = new Utils.LinearMapper(min_y,max_y,this.#y_graph + this.#graph_height,this.#y_graph);
      this.#x_map = new Utils.LinearMapper(min_x,max_x,this.#x_graph                     ,this.#x_graph+this.#graph_width);

      // Computing the tick values.
      this.#x_ticks = [];
      this.#y_ticks = [];
      var dx = (max_x - min_x)/(nx_ticks+1);
      var dy = (max_y - min_y)/(ny_ticks+1);

      var xtick = min_x;
      for (i = 0; i < nx_ticks; i++){
         xtick = xtick + dx
         this.#x_ticks.push(xtick)
      }
      
      var ytick = min_y;
      for (i = 0; i < ny_ticks; i++){
         ytick = ytick + dy
         //console.log(ytick);
         this.#y_ticks.push(ytick)
      }

   }

  
}

module.exports = SmoothLineGraph