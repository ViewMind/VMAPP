
class TextReplacer {

   #strings;
   #report;
   #error;

   constructor(strings,report){
      this.#strings = strings;
      this.#report = report;
   }

   /**
    * Searches for a string in the strings resource and the searches again for a report value referenced in the string match found. Thsi last step is done only if necessary. 
    * @param {String} [input] - Generator string.
    * @returns Generated string if everything went ok or false otherwise. 
    */

   reportString(input){
      
      this.#error = "";

      let extract = this.extractStringBetweenChars(input,"#");

      if (extract == "") return input;

      extract = this.valueAtHiearchy(extract,this.#strings);
      if (extract.error != ""){
         this.#error= "Getting report string from input " + input + " - " + extract.error;
         return false;
      }
      let extracted_string = extract.value;

      // We only do the second replacement if the pointed value is a string. If it's an object we return as is. 
      if (typeof(extracted_string) == "object") return extracted_string;

      // Now that we have the string we make sure that it's value is replaced with a report value, if necessary.
      extract = this.extractStringBetweenChars(extracted_string,"&");
      if (extract == "") return extracted_string;

      extract = this.valueAtHiearchy(extract,this.#report);
      if (extract.error != ""){
         this.#error= "Getting report value, in report string from input " + extract + " - " + extract.error;
         return false;
      }
      extracted_string = extract.value;

      return extracted_string;
   }

   reportValue(input){
      this.#error = "";
      let extract = this.extractStringBetweenChars(input,"&");
      //console.log("Extracted report value string is " + extract);
      if (extract == "") return input;

      extract = this.valueAtHiearchy(extract,this.#report);
      //console.log("After getting the string from report it is " + JSON.stringify(extract));
      if (extract.error != ""){
         this.#error= "Getting report value, in report string from input " + extract + " - " + extract.error;
         return false;
      }
      return extract.value;
   }

   getError(){
      return this.#error;
   }

   /**
    * Returns a substrign delimited by instances of the char delimiter. For example: input = "some weird string with chars" and a delimiter of "w"
    * will return "eird string ". 
    * @param {string} [input]     - The string in which to search for delimiters. 
    * @param {string} [delimiter] - Should be one character long.  
    * 
    * @returns The string between two intances of the delimiter, withouth the actual delimiter. Or null if at least two instance of them, were not found. 
    */

    extractStringBetweenChars(input,delimiter){
      let buffer = "";
      let is_buffering = false;
      for (let i = 0; i < input.length; i++){
         if (input[i] == delimiter){
            if (is_buffering){
               // We've found the second character and need to exti.
               return buffer;
            }
            else{
               is_buffering = true;
            }
         }
         else if (is_buffering){
            buffer = buffer + input[i];
         }
      }
      return "";
   }

   /**
    * Simply calls valueAtHiearchy for a given reference string and the language string collection.
    * @param {string} reference The hiearchical reference string.
    * @returns The string defined for the language object pointed by the hiearchical reference. 
    */
   getReportStringByReference(reference){
      return this.valueAtHiearchy(reference,this.#strings);
   }

   /**
    * Uses a hiearchy string to verify the exitance and access an object value.
    * A hieararchy string is a "."-separated string in which each word represents the key at the current level of the object. 
    * @param {string} [hieararchy_string] - The . separated string to access an objects value.
    * @param {Object} object - The object from which we want to extract a value.
    * @returns The return is a object with two fields {value: value, error: error_string}. If there were no issues error will be an empty string and value will contain the returned value. Othewise value will be an empty object. 
    */

   valueAtHiearchy(hieararchy_string,object){
      let keys = hieararchy_string.split(".");
      let ret = { value: {}, error: "" };
      let obj = object;
      for (let i = 0; i < keys.length; i++){
         if (typeof(obj) == "object"){
            if (keys[i] in obj){
               obj = obj[keys[i]];
            }
            else{
               ret.error = "Requested value does not exist as object does not contain key " + keys[i] + " in hiearchy " + hieararchy_string;
               return ret;
            }
         }
         else{
            ret.error = "Found a non - array before end of hiearchy. Original string is " + hieararchy_string + " no array at level before " + keys[i];
            return ret;
         }
      }
      ret.value = obj;
      return ret;
   }   

}

module.exports = TextReplacer;