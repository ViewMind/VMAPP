const BindingDrawer = require('./binding_drawer');
const GoNoGoDrawer = require('./gonogo_drawer');
//const NBackDrawer = require('Â·/nback_drawer');
const NBackDrawer = require('./nback_drawer')
const Utils = require('./report_utils');

class FixationDrawer {

   // Parameters.
   #pdf
   #config

   // Constants.
   #LINE_WIDTH;
   #FIX_RADIOUS      = 0.04; //% of the bb.h
   #BORDER_FIXATION  = 0.02;
   
   /**
    * @param {jsPDF Instance} [pdf]
    */

   constructor(pdf){
      this.#pdf = pdf;
      
   }

   /**
    * Draws the screen and fixations over a schematized background corresponding to the configured study
    * @param {Object} [config] - Configuration parameters to actuall draw the fixations.
    * @param {Object} [boundingRect] - Position and size to draw the fixation screen.
    * @param {number} [config.boundingRect.x] - The x coordinate of the top left of the bounding rect. 
    * @param {number} [config.boundingRect.y] - The y coordinate of the top left of the bounding rect. 
    * @param {number} [config.boundingRect.w] - The width of the bounding rect. 
    * @param {number} [config.boundingRect.h] - The height of the bounding rect. 
    * @param {string} [config.label] - Optional. If present it will write a vertical line label on the left side of the box. This will fall outside the bounding box. 
    * @param {string} [config.title] - Optional. If present it will write a horizontal line at top of the fixation. This will fall outside of the bounding box. 
    * @param {Array}  [config.resolution] - 2 number  only. The resolution area represented by the boundingRect (should corrspond to the pixel draw area from the study)
    * @param {Array}  [config.fixations]  - The fixations to draw in the original coordinates. Each item is a 2 value array of the (x,y) coordinates in the original monitor system.
    * @param {Array}  [config.binding] - Optional. If present background will correspond to bindign trial. Item position in order to draw squares. Can have 2 or 3 values, correspondign to a binding of 2/3 targets. Each item has two values a row and column. 
    * @param {Array}  [config.gonogo] - Optional. If present background will correspond to gonogo trial. Description can be either 'R->','R<-','G->' or 'G<-'. The last one is the default.     
    * @param {boolean}[config.enable_legacy_scaling] - Optiona. If present and true it eanbles the secondary scaling of the DrawConstantCalculator required for some legacy fixation drawing. 
    * @param {boolean}[config.use_colored_title] - Optional. If present then the color of the title of the screen will be blue instead of black. 
    */

   render(config){
      this.#config = config;

      this.#LINE_WIDTH = Utils.DimensionMapper.dh(1.5);
      //console.log("Set line width in fixation drawer to " + this.#LINE_WIDTH)

      if ("use_colored_title" in this.#config){
         this.renderBackground(true)
      }
      else {
         this.renderBackground(false);
      }
      

      if ("binding" in config){
         var bindingConfig = {}      
         bindingConfig.original_resolution = this.#config.resolution;
         bindingConfig.target_resolution = [this.#config.boundingRect.w, this.#config.boundingRect.h]
         bindingConfig.lineWidth = this.#LINE_WIDTH;
         bindingConfig.isTwo = (this.#config.binding.length === 2);
         bindingConfig.offset_x = this.#config.boundingRect.x 
         bindingConfig.offset_y = this.#config.boundingRect.y 
         if ("enable_legacy_scaling" in config) bindingConfig.enable_legacy_scaling = config.enable_legacy_scaling
         const binding = new BindingDrawer(this.#pdf,bindingConfig)

         for (i = 0; i < this.#config.binding.length; i++){
            var xandy = this.#config.binding[i];
            binding.bindingDrawFlag(xandy[0],xandy[1]);
         }
      }
      else if ("gonogo" in config){
         var gonogoConfig = {}      
         gonogoConfig.original_resolution = this.#config.resolution;
         gonogoConfig.target_resolution = [this.#config.boundingRect.w, this.#config.boundingRect.h]
         gonogoConfig.offset_x = this.#config.boundingRect.x 
         gonogoConfig.offset_y = this.#config.boundingRect.y 
         gonogoConfig.lineWidth = this.#LINE_WIDTH;
         //if ("enable_legacy_scaling" in config) gonogoConfig.enable_legacy_scaling = config.enable_legacy_scaling
         const gonogo = new GoNoGoDrawer(this.#pdf,gonogoConfig)

         gonogo.drawTrial(config.gonogo);

      }
      else if ("nback" in config){
         var nbackConfig = {};
         nbackConfig.boundingBox = this.#config.boundingRect;
         nbackConfig.resolution = this.#config.resolution;
         const nback = new NBackDrawer(this.#pdf,nbackConfig);
         if (config.nback.length > 0) nback.renderTrial(config.nback)
         else nback.renderTrial()
      }
      

      this.drawFixations();

   }

   renderBackground(use_color_label){

      // Drawing the Screen.
      this.#pdf.setLineWidth(this.#LINE_WIDTH);
      this.#pdf.setDrawColor(Utils.Colors.TEXT_BLACK);
      var rx = Utils.DimensionMapper.dw(10);
      var ry = Utils.DimensionMapper.dh(10);
      this.#pdf.roundedRect(this.#config.boundingRect.x,this.#config.boundingRect.y,this.#config.boundingRect.w,this.#config.boundingRect.h,rx,ry);

      // Drawing the label if present.
      if ("label" in this.#config){
         this.#pdf.setFont(Utils.FontNames.NAME, Utils.FontNames.HEAVY)
         this.#pdf.setTextColor(Utils.Colors.DARK_BLUE);
         this.#pdf.setFontSize(Utils.FontSizes.NORMAL);

        var dim, x, y  
        dim = this.#pdf.getTextDimensions(this.#config.label);
     
        // Computing the y position so that the rotated text is centered on the graph. 
        y = this.#config.boundingRect.y + this.#config.boundingRect.h - (this.#config.boundingRect.h - dim.w)/2
        x = this.#config.boundingRect.x - dim.h; 

        let text = this.#config.label;
        text = text.toUpperCase();
     
        this.#pdf.text(text,x,y,{angle: 90, rotationDirection: 1});

      }

      // Drawing the title if present. 
      if ("title" in this.#config){
         this.#pdf.setFont(Utils.FontNames.NAME, Utils.FontNames.HEAVY)
         if (use_color_label) this.#pdf.setTextColor(Utils.Colors.DARK_BLUE);
         else this.#pdf.setTextColor(Utils.Colors.TEXT_BLACK);
         this.#pdf.setFontSize(Utils.FontSizes.NORMAL);

         var dim, x, y  
         dim = this.#pdf.getTextDimensions(this.#config.title);
         x = this.#config.boundingRect.x + (this.#config.boundingRect.w - dim.w)/2
         y = this.#config.boundingRect.y - dim.h; // Providing half a line of space between the top of the fixation box and the bottom linen of the title. 
         this.#pdf.text(this.#config.title,x,y,{baseline: "bottom"});
      }

   }


   drawFixations(){

      // The x, y scale.
      var scalex = this.#config.boundingRect.w/this.#config.resolution[0];
      var scaley = this.#config.boundingRect.h/this.#config.resolution[1];
      //var R = this.#config.boundingRect.h*this.#FIX_RADIOUS;
      var D = Utils.DimensionMapper.dh(8);
      var R = D/2

      this.#pdf.setFillColor(Utils.Colors.FIXATION_COLOR);
      this.#pdf.setDrawColor(Utils.Colors.TEXT_BLACK)
      this.#pdf.setLineWidth(Utils.DimensionMapper.dh(1.5))

      for (var i = 0; i < this.#config.fixations.length; i++){
         var f = this.#config.fixations[i];
         
         var x = this.#config.boundingRect.x + f[0]*scalex;
         var y = this.#config.boundingRect.y + f[1]*scaley;
                  
         //console.log(x + "," + y + " " + R);
         f = this.makePointFallWithinBounds([x,y],R);

         this.#pdf.circle(f[0],f[1],R,'FD');
      }

   }

   makePointFallWithinBounds(f,R){
      var x = f[0]
      var y = f[1]
      var xmin = this.#config.boundingRect.x+2*R
      var xmax = xmin + this.#config.boundingRect.w-2*R
      var ymin = this.#config.boundingRect.y+2*R;
      var ymax = ymin + this.#config.boundingRect.h-2*R;

      if (x < xmin) x = xmin;
      else if (x > xmax) x = xmax;

      if (y < ymin) y = ymin;
      else if (y > ymax) y = ymax;

      return [x,y];
   }


}

module.exports = FixationDrawer;