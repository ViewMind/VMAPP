const Utils = require('./report_utils');

class ResultBar {

   /**
    * 
    * @param {Pointer ot jsPDF} [pdf]
    * @param {Object} [buildOptions] - All the neccessary data to render the result bar. 
    * @param {number} [buildOptions.w] - The width occupied by the result bar.
    * @param {number} [buildOptions.h] - The height occupied by the result bar plus the indicator
    * @param {number} [buildOptions.x] - The x coordinate of the top left corner of the result bar's bounding rect. 
    * @param {number} [buildOptions.y] - The y coordinate of the top left corner of the result bar's bounding rect. 
    * @param {number} [buildOptions.segments] - The number of segments to use. Possible values can be 2, 3 or 4.
    * @param {number} [buildOptions.indicator] - The segment index where the indcator is pointing. In all instances, the lower the better. Needs to be a value between 0 and buildOptions.segments - 1.
    * @param {boolean} [buildOptions.dbug] - Optional. If true it draws a background around the bounding rect of the result bar. 
    */
   
   // The internal variables.
   #buildOptions;
   #pdf;

   // Computed internal values.
   #barH
   #barRelativeY
   #segmentWidth
   #air
   #segments

   // The constants. 
   #H_RATIO_FOR_INDICATOR = 0.25;
   #H_RATIO_AIR_INDICATOR = 0.4; // % of the actual inicator height. 
   #AIR_OUTSIDE_ROUNDED_RECT = 0.15; // Of the Height.
   #LINE_WIDTH = 0.6 // Absolute in mm. 
   #INDICATOR_WIDTH = 0.08 // % of the bar width

   constructor(pdf,buildOptions){
      this.#pdf = pdf;
      this.#buildOptions = buildOptions;
   }

   render(){

      // For Debugging Only. We add a Gray Area to the background. 
      if ("dbug" in this.#buildOptions){
         if (this.#buildOptions.dbug){
            this.#pdf.setFillColor("#dddddd");
            this.#pdf.setDrawColor("#dddddd");
            this.#pdf.rect(this.#buildOptions.x,this.#buildOptions.y, this.#buildOptions.w, this.#buildOptions.h,"F");
         }
      }

      // Renders the outline of the color bar.
      this.renderBarOutline();

      // Renders the actual color bar. 
      this.renderColorBar()

      // Finally the indicator is rendered.
      this.renderIndicators();

   }

   renderBarOutline(){

      // Computing the bar Height.
      this.#barH = this.#buildOptions.h - this.#H_RATIO_FOR_INDICATOR*this.#buildOptions.h*2
      this.#barRelativeY = (this.#buildOptions.h - this.#barH)/2;      
      
      // The rouding radious. 
      var rY = this.#barH/2
      var rX = rY

      this.#pdf.setDrawColor(Utils.Colors.BLACK);
      this.#pdf.setLineWidth(this.#LINE_WIDTH)
      this.#pdf.roundedRect(this.#buildOptions.x,this.#buildOptions.y + this.#barRelativeY, this.#buildOptions.w, this.#barH, rX, rY, "S");
      
   }

   renderColorBar(){

      var colors = [Utils.Colors.CODE_GREEN, Utils.Colors.CODE_YELLOW, Utils.Colors.CODE_RED];
      this.#segments = 3;
      if (this.#buildOptions.segments == 2){
         colors = [Utils.Colors.CODE_GREEN, Utils.Colors.CODE_RED];
         this.#segments = 2;
      }
      else if (this.#buildOptions.segments == 4){
         colors = [Utils.Colors.CODE_BLUE, Utils.Colors.CODE_GREEN, Utils.Colors.CODE_YELLOW, Utils.Colors.CODE_RED];
         this.#segments = 4;
      }

      
      this.#air = this.#AIR_OUTSIDE_ROUNDED_RECT*this.#barH
      var innerBarH = this.#barH - 2*this.#air;
      var innerBarW = this.#buildOptions.w - 2*this.#air; // The space between the inner and outer bar should be the same vertically and horizontally. 
      this.#segmentWidth = innerBarW/colors.length;

      var x = this.#buildOptions.x + this.#air
      var y = this.#buildOptions.y + this.#barRelativeY + this.#air
      var R = innerBarH/2;

      for (var c = 0; c < colors.length; c++){
         var color = colors[c];
         this.#pdf.setFillColor(color);
         if (c == 0){
            this.#pdf.circle(x+R,y+R,R,'F')
            this.#pdf.rect(x+R,y,this.#segmentWidth-R,innerBarH,'F');
         }
         else if (c == colors.length-1){
            this.#pdf.circle(x+this.#segmentWidth-R,y+R,R,'F')
            this.#pdf.rect(x,y,this.#segmentWidth-R,innerBarH,'F');
         }
         else {
            this.#pdf.rect(x,y,this.#segmentWidth,innerBarH,'F');
         }
         x = x + this.#segmentWidth;
      }

   }

   renderIndicators(){

      // Checking in which segment the indicator should be drawn. 
      var index = 0;
      if ((this.#buildOptions.indicator >= 0) && (this.#buildOptions.indicator < this.#segments)){
         index = this.#buildOptions.indicator
      }

      // Computing the x position of the indicator.
      var indicator_x = this.#buildOptions.x + this.#air + this.#segmentWidth/2;
      indicator_x = indicator_x + this.#segmentWidth*index;

      var indicator_h = this.#H_RATIO_FOR_INDICATOR*this.#buildOptions.h

      // Computing the indicator geometry. 
      var indicator_top_y = this.#buildOptions.y + this.#barRelativeY - (indicator_h*this.#H_RATIO_AIR_INDICATOR);
      var indicator_botom_y = indicator_top_y + this.#barH + 2*(indicator_h*this.#H_RATIO_AIR_INDICATOR);
      var indicator_w = this.#buildOptions.w*this.#INDICATOR_WIDTH;

      // Setting the "pen"
      this.#pdf.setDrawColor(Utils.Colors.BLACK);
      this.#pdf.setLineWidth(this.#LINE_WIDTH);

      // Drawing the top indicator.
      this.#pdf.setLineCap("round");      
      this.#pdf.line(indicator_x,indicator_top_y,indicator_x - indicator_w/2,indicator_top_y - indicator_h,"S");
      this.#pdf.line(indicator_x,indicator_top_y,indicator_x + indicator_w/2,indicator_top_y - indicator_h,"S");

      // Drawing the bottom indicator.
      this.#pdf.line(indicator_x,indicator_botom_y,indicator_x - indicator_w/2,indicator_botom_y + indicator_h,"S");
      this.#pdf.line(indicator_x,indicator_botom_y,indicator_x + indicator_w/2,indicator_botom_y + indicator_h,"S");
      
   }

}

module.exports = ResultBar;