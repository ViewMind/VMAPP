const DrawConstantCalculator = require("./draw_constant_calculator");
const Utils = require("./report_utils")

class NBackDrawer {

   #pdf 
   #config

   // Computed target boxes. 
   #drawTargetBoxes

   // Constants used for defining the boxes width and height. 
   #K_RECT_WIDTH                = 0.085;
   #K_RECT_HEIGHT               = 0.143;
   #K_HORIZONAL_MARGIN          = 0.06;
   #K_SPACE_BETWEEN_BOXES       = 0.09;
   #K_VERTICAL_MARGIN           = 0.06;   
   #K_CROSS_LINE_LENGTH         = 0.05;
   #LINE_WIDTH                  = 0.5;
   #TARGET_NUMBER_FONT_SIZE     = 10;

   /**
    * Draws an NBack Trial in two stages. The background is always the same:
    *    Encoding: A combination of the images where the target was being shown. This is denoted by the center cross and the numbers being drawn in the order of which the targets appeared. 
    *    Retrieval: Only the background is shown. 
    * @param {Object} [pdf] - The jsPDF instance. 
    * @param {Object} [config] - The configuration for drawing.
    * @param {Array}  [config.resolution] - The resolution in which the original screen was drawn. 0 = width, 1 = height
    * @param {Object} [config.boundingBox] - The bounding box (x,y,w,h should be defined) for this fixation screen. 
    */

   constructor(pdf,config){
      this.#pdf = pdf;
      this.#config = config;

      this.computeDrawTargetBoxes()
   }

   /**
    * This codes tries to mimick the logic for computing dimentions found at fieldingparser.cpp, parseFieldingExperiment function as close as possible
    */

   computeDrawTargetBoxes(){

      // Creating the constant calculator. 
      let dcc = new DrawConstantCalculator(this.#config.resolution[0], this.#config.resolution[1])

      let resolutionWidth = this.#config.resolution[0]
      let resolutionHeight = this.#config.resolution[1]

      // The scale for the boxes to fit the desired page area. 
      var scalex = this.#config.boundingBox.w/resolutionWidth
      var scaley = this.#config.boundingBox.h/resolutionHeight

      // The offset for all coordinates. 
      var xoffset = this.#config.boundingBox.x;
      var yoffset = this.#config.boundingBox.y;

      let targetBoxWidth  = resolutionWidth*dcc.getHorizontalRatio(this.#K_RECT_WIDTH);
      let targetBoxHeight = resolutionHeight*dcc.getHorizontalRatio(this.#K_RECT_HEIGHT);

      // Computing the box coordinates. 

      let x0, x1, x2, x3, x4, x5;
      let y0, y1, y2, y3, y4, y5;

      // Computing the boxes's coordinates.
      x5 = resolutionWidth*dcc.getHorizontalRatio(this.#K_HORIZONAL_MARGIN);
      x2 = resolutionWidth*(1- dcc.getHorizontalRatio(this.#K_HORIZONAL_MARGIN)) - targetBoxWidth;
      x0 = x5 + targetBoxWidth + resolutionWidth*dcc.getHorizontalRatio(this.#K_SPACE_BETWEEN_BOXES);
      x4 = x0;
      x1 = x2 - targetBoxWidth - resolutionWidth*dcc.getHorizontalRatio(this.#K_SPACE_BETWEEN_BOXES);
      x3 = x1;
      y2 = resolutionHeight/2.0 - targetBoxWidth/2.0;
      y5 = y2;
      y0 = resolutionHeight*dcc.getVerticalRatio(this.#K_VERTICAL_MARGIN);
      y1 = y0;
      y3 = resolutionHeight*(1-dcc.getVerticalRatio(this.#K_VERTICAL_MARGIN)) - targetBoxHeight;
      y4 = y3

      // Creating a list with the coordinates of each of the rectangles. Each x coordiante is multiplied by scale x and then the offset is added. 
      this.#drawTargetBoxes = [];
      this.#drawTargetBoxes.push({ x: x0*scalex + xoffset, y: y0*scaley + yoffset, w: targetBoxWidth*scalex, h: targetBoxHeight*scaley });
      this.#drawTargetBoxes.push({ x: x1*scalex + xoffset, y: y1*scaley + yoffset, w: targetBoxWidth*scalex, h: targetBoxHeight*scaley });
      this.#drawTargetBoxes.push({ x: x2*scalex + xoffset, y: y2*scaley + yoffset, w: targetBoxWidth*scalex, h: targetBoxHeight*scaley });
      this.#drawTargetBoxes.push({ x: x3*scalex + xoffset, y: y3*scaley + yoffset, w: targetBoxWidth*scalex, h: targetBoxHeight*scaley });
      this.#drawTargetBoxes.push({ x: x4*scalex + xoffset, y: y4*scaley + yoffset, w: targetBoxWidth*scalex, h: targetBoxHeight*scaley });
      this.#drawTargetBoxes.push({ x: x5*scalex + xoffset, y: y5*scaley + yoffset, w: targetBoxWidth*scalex, h: targetBoxHeight*scaley });

   }

   /**
    * Renders a encoding or retrieval trial depending if trial is an array or undefined. 
    * @param {Array|undefined} [trial] - If defined the array should be an array of numbers between 0 and 5 indicating the trial description. This will draw numbers on the target boxes in the order where the red dot originally appeared, plus the center cross. Otherwise it will draw an empty background.
    */

   renderTrial(trial){

      // Rendering the background. 
      this.#pdf.setLineWidth(Utils.DimensionMapper.dh(1));
      this.#pdf.setDrawColor(Utils.Colors.TEXT_GRAY);      
      
      this.#pdf.setFont(Utils.FontNames.NAME, Utils.FontNames.NORMAL)
      this.#pdf.setTextColor(Utils.Colors.TEXT_GRAY);
      this.#pdf.setFontSize(Utils.FontSizes.SMALL);

      for (var i = 0; i < this.#drawTargetBoxes.length; i++){
         let tbox = this.#drawTargetBoxes[i];
         this.#pdf.rect(tbox.x,tbox.y,tbox.w,tbox.h,"S");
      }

      if (trial !== undefined){

         // Creating the constant calculator. Copying mostly from fieldingmanager.cpp, function: drawBackground
         let dcc = new DrawConstantCalculator(this.#config.resolution[0], this.#config.resolution[1])
   
         let ScreenResolutionWidth = this.#config.resolution[0]
         let ScreenResolutionHeight = this.#config.resolution[1]

         // The scale for the boxes to fit the desired page area. 
         var scalex = this.#config.boundingBox.w/ScreenResolutionWidth
         var scaley = this.#config.boundingBox.h/ScreenResolutionHeight

         // The offset for all coordinates. 
         var xoffset = this.#config.boundingBox.x;
         var yoffset = this.#config.boundingBox.y;

         let centerX = ScreenResolutionWidth*scalex/2 + xoffset;
         let centerY = ScreenResolutionHeight*scaley/2 + yoffset;
     
         // Drawing the center cross. 
         let halfLine = ScreenResolutionWidth*dcc.getHorizontalRatio(this.#K_CROSS_LINE_LENGTH)/2.0;
         halfLine = halfLine*scalex;

         this.#pdf.line(centerX-halfLine,centerY,          centerX+halfLine, centerY,"S");
         this.#pdf.line(centerX,         centerY-halfLine, centerX,          centerY+halfLine, "S");         

         // Drawing the target numbers. 
         for (var i = 0; i < trial.length; i++){
            let bb = this.#pdf.getTextDimensions(trial[i]);
            let tbox = this.#drawTargetBoxes[trial[i]];
            let x = tbox.x + (tbox.w - bb.w)/2;
            let y = tbox.y + (tbox.h - bb.h)/2;
            let text = "" + (i+1)
            this.#pdf.text(text,x,y,{baseline: "top"});
         }

      }

   }

}

module.exports = NBackDrawer