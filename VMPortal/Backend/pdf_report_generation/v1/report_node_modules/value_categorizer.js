 
class ValueCategory {

   #label;
   #category;
   #error;

   /**
    * To construct a value category the construct string must be in the following form
    * valueA valueB.
    * valueA MUST be <= valueB and they must both be numbers
    * If an * is after either value the value boundary itself is part of the range. 
    * - represents no lower bound while + represents no hight bound.       
    * @param {string} [construct_string] - The string that constructs the value category.
    * @param {number|string} label - The 'name' assigned to the category.
    */

   constructor(construct_string,label){
      this.#label = label;
      
      this.#error = "";

      let parts = construct_string.split(" ");
      if (parts.length != 2){
         this.#error = "Badly formatted category string, incorrect part count |" + construct_string + "|";
         return;
      }

      this.#category = {};

      let ret = this.parseNumber(parts[0],"low");
      if (!ret.ok){
         this.#error = "Invalid numeric value for lower bound: |" + parts[0] + "|";
         return;      
      }
      this.#category.min = ret.value;
      this.#category.include_min = ret.include;

      ret = this.parseNumber(parts[1],"high");
      if (!ret.ok){
         this.#error = "Invalid numeric value for higher bound: |" + parts[1] + "|";
         return;      
      }
      this.#category.max = ret.value;
      this.#category.include_max = ret.include;

      if ((this.#category.min != "-") && (this.#category.max != "+")){
         if (this.#category.min > this.#category.max){
            this.#error = "Bad range " + this.#category.min + " > " + this.#category.max;
            return;
         }
      }

   }

   parseNumber(value, high_or_low){

      let ret = {value : 0, include: false, ok: true};

      let alt = "+";
      if (high_or_low == "low") alt = "-";

      // Parsing the string. If the value ends with * it implies the bound falls within the range. And the only valid non numeric value is either - for the first
      // or + for the second (high value). 
      let asterisk = value.charAt(value.length-1);
      if (asterisk == "*"){
         ret.include = true;
         value = value.substr(0,value.length-1);
      }  
      
      if (value != alt){
         if (isNaN(parseFloat(value))){
            ret.ok = false;
            return;
         }
      }
      ret.value = value;
      return ret;

   }

   valueInCategory(value){

      if (this.#category.min != "-"){
         if (this.#category.include_min){
            if (value < this.#category.min) return false;
         }
         else{
            // If the min boundary is NOT included, then if $value is equal, then the value is NOT in the category.
            if (value <= this.#category.min) return false;
         }
      }

      // Lower bound checks. Now we check for the upper bound. 
      if (this.#category.max != "-"){
         if (this.#category.include_max){
            if (value > this.#category.max) return false;
         }
         else{
            // If the min boundary is NOT included, then if $value is equal, then the value is NOT in the category.
            if (value >= this.#category.max) return false;
         }
      }

      return true;

   }

   getError(){
      return this.#error;
   }

   getLabel(){
      return this.#label;
   }

}

class SegmentClassifier {

   #categories;
   #errors;
   
   /**
    * It is essentialy a container for an Array of Value Category.
    * The constructor takes an object that is a map of the form 'label' => 'construction_string'.
    * @param {Object} [categories_and_ranges] - An dictionary object where the key is the label and the value is the ValueCategory construction string. 
    */
   constructor(categories_and_ranges){

      this.#errors = [];
      this.#categories = [];

      for (var label in categories_and_ranges){

         var range = categories_and_ranges[label];

         let c = new ValueCategory(range,label);
         if (c.getError() != ""){
            this.#errors.push(c.getError());
         }

         this.#categories.push(c);

      }
      
   }

   /**
    * Runs the value and returs the label of the matching range.
    * If no match is found it will return an empty string.
    * If there are errors it will also return an empty string. 
    */

   categorize(value){
      if (this.#errors.length != 0) return "";

      for (var i = 0; i < this.#categories.length; i++){
         let category = this.#categories[i];
         if (category.valueInCategory(value)){
            return category.getLabel();
         }
      }

      return "";
   }

   getErrors(){
      return this.#errors;
   }   

}

//// Testing.
// let cats = {
   //  "1": "- 2*",
   //  "0": "2 3.5*",
   // "-1": "3.5 5*",
   // "-2": "5 7*",
   // "-3": "7 +"
// }
// 
// let segment = new SegmentClassifier(cats);
// if (segment.getErrors().length > 0){
   // console.log(segment.getErrors());
   // return;
// }
// let value = 8;
// console.log(value,"=>",segment.categorize(value));

module.exports = SegmentClassifier