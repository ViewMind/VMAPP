const DrawConstantCalculator = require("./draw_constant_calculator");
const Utils = require('./report_utils');

class BindingDrawer {


   // PDF drawer
   #pdf   

   // Parameters. 
   #original_screen_w
   #original_screen_h
   #target_w
   #target_h
   #lineWidth   
   #offset_x
   #offset_y

   // Computed draw values. 
   #draw

   /**
    * Simplified class that draws the binding flags in the same manner as the Qt App counterpart.
    * @param {jsPDF Instance} pdf 
    * @param {Array}   [config.original_screen] - Two value resolution where the original flags were drawn.
    * @param {Array}   [config.target_rect]     - Two value width and height of the rectangle representing the screen in the pdf.
    * @param {number}  [config.lineWidth]       - The line width to use when drawing. 
    * @param {boolean} [config.useTwo]          - True for 2 target binding, false for 3. 
    */
   
   constructor(pdf, config){
      this.#original_screen_h = config.original_resolution[1];
      this.#original_screen_w = config.original_resolution[0];
      this.#target_w = config.target_resolution[0]
      this.#target_h = config.target_resolution[1]      
      this.#lineWidth = config.lineWidth;
      this.#offset_x  = config.offset_x
      this.#offset_y  = config.offset_y
      this.#pdf = pdf;

      let enable_legacy_scaling = false;
      if ("enable_legacy_scaling" in config){
         if (config.enable_legacy_scaling) enable_legacy_scaling = true;
      }

      this.bindingDrawSetup(config.isTwo,config.enable_legacy_scaling);

   }

   /**
    * /Algorithm copied straight out of the Qt Application. It will draw the flags in grid position computed according to the rules of hte application in original resolution and the scaled to fit into the target rect. 
    * @param {number} [x_index] index for the value for the x position to draw the flag 
    * @param {number} [y_index] index for the value for the y position to draw the flag. 
    */
   bindingDrawFlag(x_index, y_index){

      this.#pdf.setLineWidth(this.#lineWidth);
      this.#pdf.setDrawColor(Utils.Colors.MAIN_BLUE);
      this.#pdf.setFillColor(Utils.Colors.MAIN_BLUE);
      var scalex = this.#target_w/this.#original_screen_w
      var scaley = this.#target_h/this.#original_screen_h

      //console.log(JSON.stringify(this.#draw));

      // Drawing the back. 
      var backw = this.#draw.FlagSideH*scalex;
      var backh = this.#draw.FlagSideV*scaley;
      var x = this.#draw.xpos[x_index]*scalex;
      var y = this.#draw.ypos[y_index]*scaley;
      x = x + this.#offset_x;
      y = y + this.#offset_y;
      this.#pdf.rect(x,y,backw,backh,"S");
      //console.log("Scale X " + scalex + ". Y: " + scaley);
      //console.log(x,y,backw,backh);

      // Drawing the vertical 
      x = this.#offset_x + (this.#draw.xpos[x_index] + this.#draw.HLBorder)*scalex
      y = this.#offset_y + (this.#draw.ypos[y_index] + this.#draw.VSBorder)*scaley
      var w = (this.#draw.FlagSideH-2*this.#draw.HLBorder)*scalex
      var h = (this.#draw.FlagSideV-2*this.#draw.VSBorder)*scaley
      //console.log(x + "," + y + " " + "  " + w + "x" + h)
      this.#pdf.rect(x,y,w,h,'F');

      // Drawing the horizontal 
      x = this.#offset_x + (this.#draw.xpos[x_index] + this.#draw.HSBorder)*scalex
      y = this.#offset_y + (this.#draw.ypos[y_index] + this.#draw.VLBorder)*scaley
      w = (this.#draw.FlagSideH-2*this.#draw.HSBorder)*scalex
      h = (this.#draw.FlagSideV-2*this.#draw.VLBorder)*scaley
      this.#pdf.rect(x,y,w,h,'F');

   }

   /**
    * Adpated function from C++ code. Generates a draw object that can then easily generate parametrized binding squares based on the resolution
    * @param {boolean} [useTwo] True for two targets. False for 3
    * @param {boolean} [enable_legacy_scaling] If true it enables the secondary scaling of the DrawConstantCalculator. 
    */
   bindingDrawSetup(useTwo,enable_legacy_scaling){

      var horizontalGridPoints
      if (useTwo) horizontalGridPoints = 2;
      else horizontalGridPoints = 3;

      var drawValues = this.bindingDrawValues(useTwo,enable_legacy_scaling)

      var drawStructure = {}
      var ScreenResolutionWidth = this.#original_screen_w
      var ScreenResolutionHeight = this.#original_screen_h

      drawStructure.FlagSideH = drawValues.sideh*ScreenResolutionWidth;
      drawStructure.FlagSideV = drawValues.sidev*ScreenResolutionHeight;
      drawStructure.HSBorder  = drawValues.hs*ScreenResolutionWidth;
      drawStructure.VLBorder  = drawValues.vl*ScreenResolutionHeight;
      drawStructure.HLBorder  = drawValues.hl*ScreenResolutionWidth;
      drawStructure.VSBorder  = drawValues.vs*ScreenResolutionHeight;

      var Gxpx = drawValues.gx*ScreenResolutionWidth;
      var Gypx = drawValues.gy*ScreenResolutionHeight;

      var Sx = drawValues.sideh*ScreenResolutionWidth;
      var Sy = drawValues.sidev*ScreenResolutionHeight;

      // Total horizontal space required by the placement grid
      var Wx = Gxpx*(horizontalGridPoints-1) + Sx;
      // Total vertical space required by the placement grid
      var Wy = Gypx*2 + Sy;

      var Xog = (ScreenResolutionWidth - Wx)/2;
      var Yog = (ScreenResolutionHeight - Wy)/2;

      drawStructure.xpos = []
      drawStructure.ypos = []

      for (var i = 0; i < horizontalGridPoints; i++){
          drawStructure.xpos.push(Xog + (i*Gxpx));
      }

      for (var j = 0; j < 3; j++){
          drawStructure.ypos.push(Yog + (j*Gypx));
      }

      this.#draw = drawStructure;

   }


   /**
    * Computed constants here are the same as those in the actual application. 
    */
   bindingDrawValues(useTwo,enable_legacy_scaling){

      const dcc = new DrawConstantCalculator(this.#original_screen_w,this.#original_screen_h);
      if (enable_legacy_scaling) dcc.enableSecondRescale()

      var drawValues = {};
      drawValues.sideh = dcc.getHorizontalRatio(0.0942708);
      drawValues.sidev = dcc.getVerticalRatio(0.167593);
      drawValues.hl    = dcc.getHorizontalRatio(0.0244792);
      drawValues.hs    = dcc.getHorizontalRatio(0.00208333);
      drawValues.vl    = dcc.getVerticalRatio(0.0592593);
      drawValues.vs    = dcc.getVerticalRatio(0.0222222);

      if (useTwo){
          drawValues.gx = dcc.getHorizontalRatio(0.266667);
          drawValues.gy = dcc.getVerticalRatio(0.177778);
      }
      else{
          // Assuming 3 targets
          drawValues.gx = dcc.getHorizontalRatio(0.133333);
          drawValues.gy = dcc.getVerticalRatio(0.177778);
      }

      return drawValues;
   }

}

module.exports = BindingDrawer