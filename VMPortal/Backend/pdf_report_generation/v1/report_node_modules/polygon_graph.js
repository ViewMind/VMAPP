const Utils = require('./report_utils');

class PolygonGraph {

   // Parameters
   #pdf

   // Computed
   #vertices
   #value_label_y


   // Constants.
   #LINE_WIDTH = 0.25
   #LABEL_LEFT_SIDE_MARGIN = 0.01  //% of the bouding square side.
   #FIXED_DISTANCE_TO_LABEL = 0.02 //% of the bouding square side.


   /**
    * 
    * Createa a polygonal graph with levels. The constructor itself does everything except compute the actual shaded area in the middle with the values. 
    * The dimensions of the graph will only include the actual graph. The labels in the vertices will need to fall outside of it.
    * Once the constructor finsihes the final bounding box of the graph can be accessed via getBoundingBox()
    * @param {jsPDF Instance} [pdf]
    * @param {Object} [configuration] - Configuration to draw the graph. 
    * @param {number} [configuration.x] - The x position of the bounding square for the graph
    * @param {number} [configuration.y] - The y position of the bounding square for the graph
    * @param {number} [configuration.l] - The length of th bounding square. 
    * @param {number} [configuration.levels] - Array of strings for the label for each level in the graph. It's legth is the number of levels-1. Highest is zero, lowest (the center) is configuration.levels.length
    * @param {number} [configuration.separator] - Optional. If present it should belong to the index of one of the levels. That level line will be drawn with a thick main blue color. 
    * @param {Array}  [configuration.values] - If configuration.ranges is undefined, then this is the index correspondig to the level for the vertex in the same index as vertex_labels. Should be a number beteen 0 and configuration.levels.length-1
    * If configuration.ranges is defined, then this is the value of the variable. The end vertex point is computed.
    * @param {Array}  [configuration.vertex_labels] - The strings to label each vertex. They will be split into multiple lines at \n and the number is the number of vertexes in the graph. 
    * @param {Array}  [configuration.range] - Optional. If defined is an array with the maximum and minimum value for continous computation. This assume that scale of all variables (points in the polygon is the same)
    */

   constructor(pdf, configuration){

      this.#pdf = pdf;

      // pdf.setFillColor("#aaaaaa");
      // pdf.rect(configuration.x,configuration.y,configuration.l,configuration.l,"F");

      // pdf.setDrawColor("#ff0000");
      // pdf.circle(configuration.x+configuration.l/2,configuration.y+configuration.l/2,configuration.l/2,"S")

      //this.renderPolygon(this.computeVertices(configuration.x,configuration.y,configuration.vertex_labels.length,configuration.l/2))

      var n = configuration.vertex_labels.length;
      var nv = configuration.values.length
      if (nv != n){
         console.log("Number of values is " + nv + " but the number of vertices is " + n);
         return;
      }

      // First we compute all vertices for each level
      var R = configuration.l/2;
      var L = configuration.levels.length;
      
      var dR = R/L;

      this.#vertices = [];
      this.#value_label_y = [];

      for (var l = 0; l < L; l++){
         var r = R - dR*l; 
         var vertices = this.computeVertices(configuration.x+dR*l,configuration.y+dR*l,n,r);
         
         // Finding the smallest y value.
         var ylabel = configuration.y + configuration.l;
         for (var j = 0; j < vertices.length; j++){
            if (ylabel > vertices[j][1]) ylabel = vertices[j][1];
         }

         this.#value_label_y.push(ylabel);


         //console.log(vertices);
         this.#vertices.push(vertices);
      }

      //console.log(this.#vertices)

      // The we do the fill.
      var center_x = configuration.x+configuration.l/2
      var center_y = configuration.y+configuration.l/2    
      //this.renderFilledGraph(configuration.values, configuration.range, center_x,center_y)  
      
      var sepline = -1;
      if ("separator" in configuration){
         if ((configuration.separator >= 0) && (configuration.separator < L)){
            sepline = configuration.separator;
         }         
      }

      // We add the lines from center to vertices.       
      this.renderCenterToVertexLines(center_x,configuration.y+configuration.l/2);

      // The we render all polygons.
      for (var i = 0; i < this.#vertices.length; i++){
         this.renderPolygon(this.#vertices[i],(i === sepline));
      }

      // Adding the level labels. 
      this.renderLevelLabels(configuration.levels,configuration.l,center_x,((n % 2) === 0))

      this.renderFilledGraph(configuration.values, configuration.range, center_x,center_y)

      // Finally, we render the vertex labels
      this.#pdf.setFont(Utils.FontNames.NAME, Utils.FontNames.NORMAL)
      this.#pdf.setTextColor(Utils.Colors.TEXT_GRAY);
      this.#pdf.setFontSize(Utils.FontSizes.SMALL);

      var vertices = this.#vertices[0]; // The outer level vertices.
      for (var i = 0; i < vertices.length; i++){
         var text = configuration.vertex_labels[i];
         var vtx = vertices[i];
         var center_on_middle = ((i == 0) && (n % 2) != 0);
         this.renderTextRelativeToReference(configuration.x,configuration.y,text,vtx,configuration.l,center_on_middle);
      }

   }

   renderPolygon(vertices, isSeparator){
      
      if (isSeparator){
         this.#pdf.setLineWidth(Utils.DimensionMapper.dh(1)*1.5);
         this.#pdf.setDrawColor(Utils.Colors.POLYGRAPH_SEP);
      }
      else{
         this.#pdf.setLineWidth(Utils.DimensionMapper.dh(1));
         this.#pdf.setDrawColor(Utils.Colors.POLYGRAPH_LINE);
      }
      
      var path = [];
      for (var i = 0; i < vertices.length; i++){
         var temp = {};
         temp.op = "l";
         if (i == 0){
            temp.op = "m";
         }
         temp.c = vertices[i];
         path.push(temp);
      }

      // Closing the path.
      path.push({op: "h", c: []});
      this.#pdf.path(path);
      this.#pdf.stroke();

   }

   renderLevelLabels(labels, bouding_square_size, cx, even_number_of_vertices){
      var L = labels.length;

      this.#pdf.setFont(Utils.FontNames.NAME, Utils.FontNames.NORMAL)
      this.#pdf.setTextColor(Utils.Colors.TEXT_BLUE);
      this.#pdf.setFontSize(Utils.FontSizes.NORMAL);

      var margin = bouding_square_size*this.#LABEL_LEFT_SIDE_MARGIN;
      
      var x = cx;
      var axis = cx;
      if (!even_number_of_vertices) {
         x = x + margin;
         // Finding the axis around which to center all values, vertically
         axis = 0;
         for (var i = 0; i < L; i++){
            var text = labels[i];
            //var text_array = text.split("\n");
            var bb = this.#pdf.getTextDimensions(text);
            var temp = x + bb.w/2;
            if (temp > axis) axis = temp;
         }
      }

      for (var i = 0; i < L; i++){
         var text = labels[i];
         //var text_array = text.split("\n");
         var bb = this.#pdf.getTextDimensions(text);
         var y = this.#value_label_y[i];
         //console.log(text,x,y)
         var cx = axis - bb.w/2
         this.#pdf.text(text,cx,y,{baseline: "bottom"})
      }

   }

   renderCenterToVertexLines(cx,cy){

      this.#pdf.setLineWidth(Utils.DimensionMapper.dh(1));
      this.#pdf.setDrawColor(Utils.Colors.POLYGRAPH_LINE);

      var outer_vertices = this.#vertices[0];

      for (var i = 0; i < outer_vertices.length; i++){
         this.#pdf.line(cx,cy,outer_vertices[i][0],outer_vertices[i][1],"S");
      }

   }

   /**
    * // Computes and draw the path tha forms the fill inside the graph, which varies with the values passed as a parameter. 
    * @param {Array} [values] - The array of indexes tha correspond to the level for each value. 
    * @param {Array} [range]  - Optional. If defined the the maximum and minimum value representing the range of the variable from the center to the end. 
    * @param {Array} [center_x] - The center of the circle that generates the polygon, x coordinate. Used only if range is defined.
    * @param {Array} [center_y] - The center of the circle that generates the polygon, y coordinate. Used only if range is defined.
    */
   renderFilledGraph(values,range, center_x, center_y){

      var path = [];

      if (range === undefined){
         for (var i = 0; i < values.length; i++){
            var level_index = values[i];
            var temp = {};
            temp.op = "l";
            if (path.length == 0){
               temp.op = "m"
            }
            if (level_index < 0){
               // Caping the max, just in case, which is level zero.
               temp.c = this.#vertices[0][i]
            }
            else if (level_index < this.#vertices.length){
               temp.c = this.#vertices[level_index][i]
            }
            else{
               // This should mean level_index that representes the 
               temp.c = [center_x, center_y];
            }
            path.push(temp);
         }
      }
      else{

         // These represent the maximum value. 
         var outer_vertices = this.#vertices[0];
         var isodd = ((outer_vertices.length % 2) != 0)

         // Computing the scale tranformation. 
         var P1 = outer_vertices[0];
         var Dy = (P1[1] - center_y);
         var Dx = (P1[0] - center_x);
         var D = Math.sqrt(Dx*Dx + Dy*Dy); // The distance from the center to any of the outer vertices. 
         var scale_m = D/(range[1] - range[0]);
         var scale_b = -scale_m*range[0];

         for (var i = 0; i < values.length; i++){
            
            // First we compute the scale distance.
            var l = values[i] * scale_m + scale_b;
            // Clamping the maximum and minimum distance.
            if (l < 0) l = 0; 
            if (l > D) l = D;

            var px, py;
            if ((isodd) && (i === 0)){
               // Slope is infinite the the x coordinate is the same as the center_x and y is equal just the l distance.
               px = center_x;
               py = center_y - l;
            }
            else{

               // The slope and indepent value fo the lien conecting the center to the correspoinding outer vertex
               var P1 = outer_vertices[i];
               // console.log("Vertex")
               // console.log(P1);
               // console.log("Center")
               // console.log(center_x,center_y)

               var m = (P1[1] - center_y)/(P1[0] - center_x);
               var b = center_y - m*center_x;
   
               // console.log("D and l")
               // console.log(D,l,range,values[i]);
               // console.log("m and b")
               // console.log(m,b);
   
               // Computing the coefficients of the Baskara equation.
               var K = b - center_y;
               var A = (1 + m*m);
               var B = (2*m*K - 2*center_x);
               var C = K*K + center_x*center_x - l*l;
               // console.log("A B and C");
               // console.log(A,B,C);
   
               var BaskaraA = -B/(2*A);
               var BaskaraB = Math.sqrt(B*B - 4*A*C)/(2*A);
               // console.log(BaskaraB);
               // console.log("Baskara parts");
               // console.log(BaskaraA,BaskaraB)
               var x1 = BaskaraA + BaskaraB;
               var x2 = BaskaraA - BaskaraB;
               // console.log("Baskara Solutions")
               // console.log(x1,x2);
               
   
               // Now Depending on the use case is which x we need to use. 
               if (P1[0] < center_x){
                  // We need the value of x to be lower than center x
                  if (x1 < center_x) px = x1;
                  else px = x2;
               }
               else{
                  // We need the value of x to be higher than center x
                  if (x1 > center_x) px = x1;
                  else px = x2;
               }
   
               // Computing the y coordinate once the x coordinate was chosen. 
               py = m*px + b;

               // var py1 = m*x1 + b;
               // var py2 = m*x2 + b;

               // console.log("Finally selected point")
               // console.log(px,py);
               // console.log("Verification")
               // console.log(m*P1[0] + b,"==",P1[1])
               // console.log(m*center_x + b,"==",center_y)
               // console.log(Math.pow(x1 - center_x,2) + Math.pow(py1 - center_y,2),"==",l*l)
               // console.log(Math.pow(x2 - center_x,2) + Math.pow(py2 - center_y,2),"==",l*l)
               // console.log(A*x1*x1 + B*x1 + C,"== 0")
               // console.log(A*x2*x2 + B*x2 + C,"== 0")
            }
            
            // Addin the point to the path. 
            var temp = {};
            temp.op = "l";
            if (path.length == 0){
               temp.op = "m"
            }
            temp.c = [px,py]
            path.push(temp);
            //console.log("============================================") 
            
         }

      }

      path.push({op: "h", c: []});

      // console.log(path);

      // doc.saveGraphicsState();
      // doc.setGState(new doc.GState({opacity: 0.2}));
      // doc.text(text, x, y, {align: 'center', baseline: 'middle'})
      // doc.restoreGraphicsState();      

      this.#pdf.setFillColor(Utils.Colors.POLYGRAPH_FILL);
      this.#pdf.path(path);

      this.#pdf.saveGraphicsState();
      this.#pdf.setGState(new this.#pdf.GState({opacity: 0.5}));
      this.#pdf.fill();
      this.#pdf.restoreGraphicsState();      

   }

   /**
    * Uses the geometric formula based on Euler's notation to inscribe a Polygon of n points in a circle.
    * @param {number} [x] - The x offset of the bounding square for the graph. 
    * @param {number} [y] - The y offset of the boundign square for the graph 
    * @param {number} [n] - The number of vertices 
    * @param {number} [R] - Radious of the circle used to compute the vertices. 
    */

   computeVertices(x,y,n,R){

      // Computation of the starting tita.
      var tita = Math.PI/2;
      if ((n % 2) == 0){
         // When even, we need to do a little math so the polygo appears as it should. 
         // Computing the polygon side length.
         var K = 2*Math.PI/n;
         var polygon_side = R*Math.sqrt(2*(1- Math.cos(K)));
         // We need the first point (when k = 0) to be at half of the side length in x and whatever it needs to in y. This guarantees the the top and bottom sides are parallell to the x axis. 
         var first_x = polygon_side/2;
         //console.log("x: " + first_x + " R: " + R);
         var first_y = Math.sqrt(R*R - first_x*first_x)
         //console.log("y: " + first_y + " R: " + R);
         tita = Math.atan(first_y/first_x);
         //console.log("tita: " + tita);
      }

      var vertices = [];
      for (var k = 0; k < n; k++){
         var xx = R*Math.cos(tita + 2*k*Math.PI/n);
         var yy = R*Math.sin(tita + 2*k*Math.PI/n);

         // Inverting the yy value due the how different coordinate systems work.
         yy = -yy;

         // Doing the translation
         xx = xx + (x + R)
         yy = yy + (y + R);

         //console.log([xx,yy])
         vertices.push([xx, yy])
      }

      //console.log(vertices);

      return vertices;

   }

   /**
    * Renders the text (which can be multiline) using refernce as the bounding box for the text corner maintaining a fixed distance 
    * to the vertex. Assumes that the font, font size and color were previously set. 
    * @param {number} X - The x coordinate of the bounding squre
    * @param {number} Y - The y coordinate of the bounding square
    * @param {string} text - The label text. Can be multiline separated by \n
    * @param {Array} vertex - The vertex against which the label is positioned
    * @param {number} l - The side of the bounding square. 
    * @param {boolean} center_on_middle - Flag which, when set to true, postions the text so that the vertex, x position is the middle of the text. Used on odd-n cases for the point at the very top. 
    */
   renderTextRelativeToReference(X,Y,text,vertex,l,center_on_middle){

      var d = l*this.#FIXED_DISTANCE_TO_LABEL;
      var offset = d/Math.sqrt(2);
      var text_array = text.split("\n");
      var bb = this.#pdf.getTextDimensions(text_array)

      if (center_on_middle){
         var x = vertex[0] - bb.w/2;
         var y = vertex[1] - offset*3; // This space is extra to account for level label. 
         y = y - bb.h
         this.#pdf.text(text_array,x,y,{baseline: "bottom"}); 
         return
      }

      var reference = this.computeTextBoundingBoxReferenceForVertex(X,Y,l,vertex)      

      if (reference == "bl"){
         var x = vertex[0] + offset;
         var y = vertex[1] - offset;  
         y = y - bb.h       
         //this.#pdf.rect(x,y,bb.w,bb.h,"S")
         this.#pdf.text(text_array,x,y,{baseline: "top"}); 
      }
      else if (reference == "br"){
         var x = vertex[0] - offset;
         var y = vertex[1] - offset;
         x = x - bb.w;
         y = y - bb.h 
         //this.#pdf.rect(x,y,bb.w,bb.h,"S")
         this.#pdf.text(text_array,x,y,{baseline: "top"}); 
      }
      else if (reference == "tl"){
         var x = vertex[0] + offset;
         var y = vertex[1] + offset;
         //this.#pdf.rect(x,y,bb.w,bb.h,"S")
         this.#pdf.text(text_array,x,y,{baseline: "top"}); 
      }
      else if (reference == "tr"){
         var x = vertex[0] - offset;
         var y = vertex[1] + offset;
         x = x - bb.w;
         //this.#pdf.rect(x,y,bb.w,bb.h,"S")
         this.#pdf.text(text_array,x,y,{baseline: "top"}); 
      }

   }

   /**
    * Computes the quadrant of the vertex and returns the optimal reference postion for a bouding text box. 
    * @param {number} x - The x coordinate of the bounding squre
    * @param {number} y - The y coordinate of the bounding square
    * @param {number} l - The bounding square side
    * @param {Array} vertex - 2-value array for the vertexis of the most outer polygon. 
    * @returns 
    */
   computeTextBoundingBoxReferenceForVertex(x,y,l,vertex){
      var xp = "r";
      if (vertex[0] > x + l/2){
         xp = "l"
      }
      var yp = "t"
      if (vertex[1] < y + l/2){
         yp = "b";
      }

      return yp + xp;
   }

}

module.exports = PolygonGraph