const DrawConstantCalculator = require("./draw_constant_calculator");
const Utils = require('./report_utils');

class GoNoGoDrawer {


   // PDF drawer
   #pdf   

   // Parameters. 
   #original_screen_w
   #original_screen_h
   #target_w
   #target_h
   #lineWidth   
   #offset_x
   #offset_y   

   // Computed draw values. 
   #draw

   // Draw constants. Taken straight from C++
   #SIDE_MARGIN               = 0.05;   // Percent of resolution width
   #TARGET_SIZE               = 0.03;   // Percent of resolution width
   #ARROW_LENGTH              = 0.1;    // Percent of resolution width
   #ARROW_INDICATOR_LENGTH    = 0.4;    // Percent of arrow length
   #CROSS_LINE_LENGTH         = 0.1;    // Percent of resolution width/height.
   #TARGET_LINE_WIDTH         = 0.1;    // Percent of the diameter.
   #LINE_WIDTH                = 0.1;    // Percent of the line length.
   #INDICATOR_LINE_LENGTH     = 0.3;    // Percent of the line length
   #ARROW_TARGET_BOX_WMARGIN  = 2.2;    // Multiplier to the arrow width
   #ARROW_TARGET_BOX_HMARGIN  = 4.5;    // Multiplier to the arrow height
   #TARGET_TOL                = 0.20;   // Percent of resolution width   

   #ARROW_WIDTH               = 0.4     // %of the height of the arrow bounding box.
   #ARROW_IND_WIDTH           = 0.25    // %of the width of the arrow bounding box   
   #PRETTY_SCALE_ARROW        = 1

   /**
    * Simplified class that draws the a GoNoGo Trial in the same manner as the Qt App counterpart.
    * @param {jsPDF Instance} pdf 
    * @param {Array}   [config.original_screen] - Two value resolution where the original flags were drawn.
    * @param {Array}   [config.target_rect]     - Two value width and height of the rectangle representing the screen in the pdf.
    * @param {number}  [config.offset_x]        - The x coordinate that of the top left bounding rect for the screen representation in the pdf.
    * @param {number}  [config.offset_y]        - The y coordinate that of the top left bounding rect for the screen representation in the pdf.
    */
   
   constructor(pdf, config){
      this.#original_screen_h = config.original_resolution[1];
      this.#original_screen_w = config.original_resolution[0];
      this.#target_w = config.target_resolution[0]
      this.#target_h = config.target_resolution[1]      
      this.#offset_x  = config.offset_x
      this.#offset_y  = config.offset_y
      this.#lineWidth = config.lineWidth;
      this.#pdf = pdf;
   }

   /**
    * Draws a go no go background base don the description. 
    * @param {string} [trialDescription] Can be either 'R->','R<-','G->' or 'G<-'. The last one is the default.     
    */

   drawTrial(trialDescription){

      var arrowColor = Utils.Colors.GONOGO_GREEN;
      var rightArrow = false;
      if (trialDescription == "R->"){
         rightArrow = true;
         arrowColor = Utils.Colors.GONOGO_RED;
      }
      else if (trialDescription == "R->"){
         rightArrow = false;
         arrowColor = Utils.Colors.GONOGO_RED;
      }
      else if (trialDescription == "G->"){
         rightArrow = true;
         arrowColor = Utils.Colors.GONOGO_GREEN;
      }

      // This is done to change the code from the original C++ as little as possible. 
      var ScreenResolutionWidth = this.#original_screen_w
      var ScreenResolutionHeight = this.#original_screen_h
      var scalex = this.#target_w/this.#original_screen_w
      //var scaley = this.#target_h/this.#original_screen_h

      var centerX = this.#offset_x + this.#target_w/2;
      var centerY = this.#offset_y + this.#target_h/2; 
  
      // Drawing targets.
      const dcc = new DrawConstantCalculator(ScreenResolutionWidth,ScreenResolutionHeight);
  
      var diameter = (ScreenResolutionWidth*dcc.getHorizontalRatio(this.#TARGET_SIZE))*scalex; // Diameter of the targets. 
      //var lwidth = diameter*this.#TARGET_LINE_WIDTH;
      var target_radious = diameter/2.0;
  
      var side_margin = dcc.getHorizontalRatio(this.#SIDE_MARGIN);
  
      var leftTargetX = this.#offset_x + ScreenResolutionWidth*side_margin*scalex + target_radious;
      var targetY = centerY;
      var rightTargetX = this.#offset_x+this.#target_w - ScreenResolutionWidth*side_margin*scalex - target_radious

      this.#pdf.setDrawColor(Utils.Colors.MAIN_BLUE)
      this.#pdf.setLineWidth(this.#lineWidth);
      this.#pdf.circle(leftTargetX,targetY,target_radious,'S');
      this.#pdf.circle(rightTargetX,targetY,target_radious,'S');
    
      // Drawing the arrows. It's hard to replicate drawing a arrow using thick lines like in the application. So the postion and bounding box of the App's arrow is computed and
      // It's draw from there. 
      
      var arrow_width = ScreenResolutionWidth*dcc.getHorizontalRatio(this.#ARROW_LENGTH)*scalex//*this.#ARROW_TARGET_BOX_WMARGIN;
      var indicator_line_length = this.#INDICATOR_LINE_LENGTH*arrow_width;
      var ka = Math.sqrt(2)*indicator_line_length/2*this.#PRETTY_SCALE_ARROW;
      var arrow_height = ka*2;
      var x = centerX - arrow_width/2;
      var y = centerY - arrow_height/2;
      var arrow_path = this.createArrowPath(x,y,arrow_width,arrow_height,rightArrow);

      //this.#pdf.setFillColor("#aaaaaa");
      //this.#pdf.rect(x,y,arrow_width,arrow_height,"F");

      this.#pdf.setDrawColor(Utils.Colors.MAIN_BLUE);
      this.#pdf.setFillColor(arrowColor);
      this.#pdf.path(arrow_path);
      this.#pdf.fillStroke();
  
   }

   createArrowPath(x,y,w,h,rightArrow){

      var path = [];
      var ind_height = (1 - this.#ARROW_WIDTH)*h/2;
      var ind_width = this.#ARROW_IND_WIDTH*w;
      var points = [];

      //console.log(x + "," + y + " " + w + "x" + h);
      //console.log(ind_height)
      //console.log(ind_width);

      if (rightArrow){
         // Points for right arrow.
         points.push([x,y+ind_height]);
         points.push([x + (w-ind_width) ,y+ind_height]);
         points.push([x + (w-ind_width) ,y])
         points.push([x + w, y + h/2]);
         points.push([x + (w-ind_width) ,y+h])
         points.push([x + (w-ind_width) ,y+h-ind_height]);
         points.push([x,y+h-ind_height]);
      }
      else{
         // Points for left arrow.
         points.push([x+w,y+ind_height]);
         points.push([x+w,y+h-ind_height]);
         points.push([x+ind_width,y+h-ind_height]);
         points.push([x+ind_width,y+h]);
         points.push([x, y + h/2]);
         points.push([x+ind_width,y]);
         points.push([x+ind_width,y+ind_height]);
      }

      
      for (var i = 0; i < points.length; i++){         
         var temp = {};
         if (i === 0){
            temp.op = "m";
         }
         else temp.op = "l";
         temp.c = points[i];
         path.push(temp);
      }

      // Closing the subpath.
      var temp = {}
      temp.op = "h"
      temp.c = [];
      path.push(temp)

      //console.log(JSON.stringify(path))

      return path;

   }

}

module.exports = GoNoGoDrawer