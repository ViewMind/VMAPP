var fs = require('fs');
const { runInThisContext } = require('vm');

const Colors = {
   MAIN_BLUE:   "#0d2543",
   
   // Generic use colors.
   BLACK: "#000000",
   WHITE: "#ffffff",

   // Dark Text Color
   DARK_TEXT_COLOR: "#4b4b4b",

   // Line graph axis label color
   LINEGRAPH_AXIS_LABEL: "#7f7f7f",

   // Result Segment Text Color
   RESULT_TEXT_COLOR: "#666666",
   
   // The code colors.
   CODE_BLUE:   "#18557f",
   CODE_GREEN:  "#479a49",
   CODE_YELLOW: "#dfaf2c",
   CODE_RED:    "#cc3a27",

   // Fixation color.
   FIXATION_COLOR: "#a6217f",

   // Polygon Graph colors
   POLYGRAPH_LINE : "#bfbfbf",
   POLYGRAPH_FILL : "#409896",
   POLYGRAPH_TEXT : "#666666",

   // Go No Go Arrow Colors. 
   GONOGO_GREEN: "#409896",
   GONOGO_RED: "#a7397f",

   // Graph colors
   GRAPH_BACKGROUND: "#f7f7f7",
   GRAPH_PURPLE: "#a73a7f",
   GRAPH_BLUE: "#3f9796",

   // Light gray for presumptive diagnosis box. 
   PRESUMPTIVE_GRAY: "#f0f0f0"

}

const ColorCategory = {
   BLUE:    "blue",
   GREEN:   "green",
   YELLOW:  "yellow",
   RED:     "red"
}

const Utils = {
   bas64EncodeFile: function (file){
      // read binary data
      var bitmap = fs.readFileSync(file);
      // convert binary data to base64 encoded string
      return Buffer.from(bitmap).toString('base64');  
   },

   /**
    * @brief Loads all fonts in the enconded fonts directory. The format requires the name to be family_name-style-(something or nothing).something. 
    * @param {string} [font_dir] - Path to the directory that contains all the fonts to load. 
    * @param {jsPDF instance} pdf 
    * 
    */
   loadFonts: function(pdf,font_dir){

      var font_files = fs.readdirSync(font_dir);
      for (i in font_files){
         var font_file = font_files[i];
         var font_data = fs.readFileSync(font_dir + "/" + font_file,{"encoding": "UTF-8"});
         var name_parts = font_file.split(".");
         var vfsFileName = name_parts[0] + ".ttf";
         var font_name_parts = name_parts[0].split("-");
         var family = font_name_parts[0];
         var stylization = font_name_parts[1];
         pdf.addFileToVFS(vfsFileName,font_data);
         //console.log("Adding " + family + " style " + stylization);
         pdf.addFont(vfsFileName,family,stylization);         
      }
      //console.log(pdf.getFontList())
   },

   /**
    * Computes the result segment index and color category.
    * Result segments can only have 2, 3 or 4 colors. So all the values and comparison are based on this. 
    * @param {Array}  [cutoffs] - Array of cutoff points (numbers) the array sould have N-1 length, where N is the number of desired segments. Cutoffs shoud always be in ascending order. 
    * @param {number} [value] - The value used to compute the index.
    * @param {boolean} [largerIsBetter] - Indicates that larger values are better.
    * 
    * @returns {Object} - The object contains two fields: the segment index (index) and the color category (color_category which can be blue, green, yellow or blue) indicated by the index. 
    */
   computeSegmentIndex: function(cutoffs, value, largerIsBetter) {

      var index = -1;
      for (var i = 0; i < cutoffs.length; i++){
         // When larger is NOT better the coparison must be strict (according to Gera's spec). Otherwise cutoff values will be represented by the same color
         if ((!largerIsBetter) &&  (value <= cutoffs[i])) {
            index = i;
            break;
         }
         // When larger is better the coparison must NOT be strict (according to Gera's spec). Otherwise cutoff values will be represented by the same color
         else if ((largerIsBetter) && (value < cutoffs[i])){
            index = i;
            break;
         }
      }
      if (index == -1) index = cutoffs.length;

      var ret = {index: -1,  color_category: ""};

      var color_selector = [];
      if (cutoffs.length == 1){
         
         color_selector = [ColorCategory.GREEN, ColorCategory.RED];
         
         if (largerIsBetter){
            if (index == 0) index = 1;               
            else index = 0;
         }

      }
      else if (cutoffs.length == 2){
         
         color_selector = [ColorCategory.GREEN, ColorCategory.YELLOW , ColorCategory.RED];
         
         if (largerIsBetter){
            if (index == 0) index = 2
            else if (index == 2) index = 0;
         }

      }
      else if (cutoffs.length == 3){
         color_selector = [ ColorCategory.BLUE, ColorCategory.GREEN, ColorCategory.YELLOW , ColorCategory.RED];
         if (largerIsBetter){
            index = cutoffs.length - index; // This transforms 0 -> 3, 1 -> 2, 2 -> 1 and 3 -> 0;
         }
      }
      else return ret;

      ret.index = index;
      ret.color_category = color_selector[index];
      
      return ret;

   }
};

/**
 * Maps a origin range to a target range, linearly
 */

class LinearMapper {

   #m
   #b

   constructor(origin_min, origin_max, target_min, target_max){
      this.#m = (target_max - target_min)/(origin_max - origin_min);
      this.#b = target_max - this.#m*origin_max;
   }

   getMappedValue(v){
      return this.#m*v + this.#b
   }

}

module.exports.Utils = Utils
module.exports.Colors = Colors
module.exports.LinearMapper = LinearMapper
module.exports.ColorCategory = ColorCategory

//console.log(Utils.computeSegmentIndex([400,800],799,true))