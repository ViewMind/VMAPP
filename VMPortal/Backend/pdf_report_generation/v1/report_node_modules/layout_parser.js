const Utils= require("./report_utils");
const ResultSegment = require("./result_segment");
const ColorCode = require("./color_code");
const SegmentClassifier = require("./value_categorizer")
const BulletedList = require("./titled_bulleted_list");
const PolygonGraph = require("./polygon_graph")
const FourPointGraph = require("./four_dot_graph")
const FixationDrawer = require("./fixation_drawer");
const PresumptiveDiagnosisBox = require("./presumptive_diagnosis_box");

const LayoutParser = {

   TEXT_FONT_SIZE: 10,


   /**
    * Verifies that all keys in keylist are object keys.
    * @param {Object} object - Object to verify.
    * @param {Array} keylist - keys that should be in the object. 
    * @returns An array with the missing keys. Empty if they are all there 
    */
   verifyAllKeys: function(object, keylist){
      var ret = []
      for (let i = 0; i < keylist.length; i++){
         if (!(keylist[i] in object)){
            ret.push(keylist[i]);
         }
      }
      return ret;
   },

   /**
    * Computes the x or y coordinate for a layout item. 
    * When the coordinate is an array a relative methodology is used. The array contains a string and a value. The string should identifed the id of a previously parsed item. Its bounding box, when parsed, should have been saved,
    * and the result put into an object which is then passed on in the field item_bounding_boxes of the item. 
    * @param {Object} [item] - A layout describing object. It should contain the coordinate field x and y. It the positioning is relative to anohter item the item_bounding_boxes should also be present. 
    * @param {string} [coordinate] - Either 'x' or 'y'
    * @returns An object with the coordinate and error fields. 
    */

   computeCoordinateValue(item,coordinate){
      let ret = {coordinate: 0, error: ""};
      if (Array.isArray(item[coordinate])){
         // When an array is used then one of the members of item should be item_bounding_boxes.
         if ("item_bounding_boxes" in item){
            let components = item[coordinate];
            let id = components[0];
            let v  = components[1];
            if (id in item.item_bounding_boxes){
               let bb = item.item_bounding_boxes[id];
               // When using relative positioning the offset become where the the item ends instead of the native effective area coordinate. 
               //console.log(id);
               //console.log(item.item_bounding_boxes);
               if (coordinate == "x"){                  
                  ret.coordinate =  bb.x + bb.w + v*item.effective_area.w            
               }
               else if (coordinate == "y"){
                  ret.coordinate =  bb.y + bb.h + v*item.effective_area.h            
               }
               else{
                  ret.error = "Unknown coordinate " + coordinate;
               }               
            }
            else{
               ret.error = "Array coordinate specified but no bouding box object with id " + id + " was found";   
            }
         }
         else{
            ret.error = "Array coordinate specified but no bouding box object was found in item";
         }
      }
      else{
         if (coordinate == "x"){
            ret.coordinate =  item.effective_area.x + item[coordinate]*item.effective_area.w            
         }
         else if (coordinate == "y"){
            ret.coordinate =  item.effective_area.y + item[coordinate]*item.effective_area.h            
         }
         else{
            ret.error = "Unknown coordinate " + coordinate;
         }
      }
      return ret;
   },

   /**
    * Parses the item object that should represent a result segment and creates the interpreted result segment into the PDF
    * @param {Object} pdf - the jsPDF instance.
    * @param {Object} item - The object describing the result segment. It should be enhanced with both the standar deviation values for each variable and the SD string fro the language. 
    * @param {Object} text_replacer - An instance of the text_replacer class.
    * @returns {Object} Has the form { id: string, error: string, boundingBox: Object, color: color_code } The error is empty if no issue was found. The id is non empty only if it exists in the item and the boundingBox returns just that. The color code is the categorization for the variable
    */

   parseResultSegment:  function(pdf, item, text_replacer, standard_deviations){

      // Output object.
      var ret = {};
      ret.error = "";

      let mandatory = ["title", "id", "range_text", "x", "y", "w", "h", "value", "nsegments", "effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Result Segment: Missing keys " + missing.join(",");
         return ret;
      }

      ret.id = item.id;

      // Getting the title. 
      let title = text_replacer.reportString(item.title);
      if (title === false){
         ret.error = "Parse Result Segment: Getting title - " + text_replacer.getError();
         return ret;
      }

      // Getting the range text. 
      let range_text = text_replacer.reportString(item.range_text);
      if (range_text === false){
         ret.error = "Parse Result Segment: Getting range text - " + text_replacer.getError();
         return ret;
      }

      // Checking if standard deviations (sd key) is part of the item. The id is the variable name. 
      if ("sd" in item){
         if (item.id in item.sd){
            let sd = item.sd[item.id];
            let sd_text = "";
            if ("sd_text" in item){
               sd_text = item.sd_text;
               if (sd_text === undefined){
                  ret.error = "SD text is undefined";
                  return ret;
               }
            }
            else{
               ret.error = "Parse Result Segment: Getting sd_text key is NOT present even though variable has a standar deviation";
               return ret;
            }

            // Finally we enhace the range text
            range_text = range_text + " (" + sd_text + ": " + sd + ")";
         }
      }


      // Getting the color name. 
      let color_name = text_replacer.reportValue(item.color_code);
      if (color_name === false){
         ret.error = "Parse Result Segment: Getting color name - " + text_replacer.getError();
         return ret;
      }

      // Storing the color code for when this returns. 
      ret.color = color_name;

      // Getting the numeric value
      let value = text_replacer.reportValue(item.value);
      if (value === false){
         ret.error = "Parse Result Segment: Getting the value - " + text_replacer.getError();
         return ret;
      }

      // Transforming the color name into an index.
      let color_index = -1;
      let color_array = [];
      if (item.nsegments == 2){
         color_array = [Utils.ColorCategory.GREEN, Utils.ColorCategory.RED];
      }
      else if (item.nsegments == 3){
         color_array = [Utils.ColorCategory.GREEN, Utils.ColorCategory.YELLOW, Utils.ColorCategory.RED];      
      }
      else if (item.nsegments == 4){
         color_array = [Utils.ColorCategory.BLUE, Utils.ColorCategory.GREEN, Utils.ColorCategory.YELLOW, Utils.ColorCategory.RED];      
      }
      else{
         ret.error = "Parse Result Segment: Invalid number of segments: " + item.nsegments;
         return ret;
      }

      color_index = color_array.indexOf(color_name);
      if (color_index == -1){
         ret.error = "Parse Result Segment: Invalid color code: " + color_name;
         return ret;
      }

      // Computing the geometry 
      ret.id = item.id;
      ret.boundingBox = this.computeItemBoundingBox(item,"Parse Color Code Explanation");
      if (ret.boundingBox.error != ""){
         ret.error = ret.boundingBox.error;
         return ret;
      }      

      // Rendering the result segment. 
      var rseg = {};
      rseg.boundingBox = ret.boundingBox;
      rseg.title = title;
      rseg.range_text = range_text;
      rseg.value = value;
      rseg.ncolors = item.nsegments;
      rseg.color_code = color_name;
      rseg.ndecimals = item.ndecimals;

      const resSeg = new ResultSegment(pdf);
      // console.log("Rendering Result Segment: ");
      // console.log(rseg);
      // console.log("===========================================");
      resSeg.renderConfiguration(rseg);

      return ret;

   },

   computeItemBoundingBox(item, error_id, coordinates_only){

      let bb = {};
      bb.error = "";

      // Computing the geometry.
      let x = this.computeCoordinateValue(item,"x");
      if (x.error != ""){
         bb.error = error_id + " error computing x coordinate: " + x.error;
         return bb;
      }
      x = x.coordinate;

      
      let y = this.computeCoordinateValue(item,"y");
      if (y.error != ""){
         bb.error = error_id +  " error computing x coordinate: " + y.error;
         return bb;
      }
      y = y.coordinate;

      bb.x = x;
      bb.y = y;

      if (coordinates_only === true){
         return bb;
      }

      let w = item.w*item.effective_area.w;
      let h = item.h*item.effective_area.h;
      bb.w = w;
      bb.h = h;
      return bb;
   },

   parseColorCode: function(pdf,item,text_replacer){

      // Output object.
      var ret = {};
      ret.error = "";

      let mandatory = ["id", "x", "y", "w", "h", "color_texts", "title", "effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Color Code Explanation: Missing keys " + missing.join(",");
         return ret;
      }

      // Computing the bounding box of the item. 
      ret.id = item.id;
      ret.boundingBox = this.computeItemBoundingBox(item,"Parse Color Code Explanation");
      if (ret.boundingBox.error != ""){
         ret.error = ret.boundingBox.error;
         return ret;
      }

      // This should provide the string array 
      let color_exps = text_replacer.reportString(item.color_texts);
      if (color_exps === false){
         ret.error = "Parse Color Code Explanations: " + text_replacer.getError();
         return ret;
      }

      let title = text_replacer.reportString(item.title)
      if (title === false){
         ret.error = "Parse Color Code Explanations: " + text_replacer.getError();
         return ret;
      }


      var cc = {};
      cc.boundingBox = ret.boundingBox;
      cc.color_texts = color_exps;
      cc.title = title;
      const colorcode = new ColorCode(pdf,cc);

      return ret;

   },

   parseBulletedList: function(pdf,item,text_replacer){

      // Output object.
      var ret = {};
      ret.error = "";

      let mandatory = ["id", "x", "y", "title", "effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Bulleted List: Missing keys " + missing.join(",");
         return ret;
      }      

      ret.id = item.id;

      // Getting the title. 
      let title = text_replacer.reportString(item.title)
      if (title === false){
         ret.error = "Parse Bulleted List: " + text_replacer.getError();
         return ret;
      }      

      // Computing the x, y position. 
      let bb = this.computeItemBoundingBox(item,"Parse Bulleted List", true);
      if (bb.error != ""){
         ret.error = bb.error;
         return ret;
      }    
     
      let itemized_list = [];
      
      if ("dynamic_bullets" in item){

         //console.log(item);

         // The reference color to use from item color codes for the itemized list
         let ref_colors = item.dynamic_bullets.ref_color;
         
         // The base string that neds to be used in order to get an item. 
         let basestring = item.dynamic_bullets.basestring; 

         // This is the list of variables that actually will go into list. They all should have a corresponding string. 
         let valid = item.dynamic_bullets.variables;

         // The color reference might be an array if more than one color index points to the same list. 
         // So in order to make the code general if it's not an array, we make it one by simply transforming the
         // variable into an array. 

         if (!Array.isArray(ref_colors)){
            ref_colors = [ ref_colors ];
         }

         //console.log(JSON.stringify(item.variable_color_codes));

         // Any of the colors are on the list, then they are added to the variables for THIS bulleted list. 
         for (var index in ref_colors){
            ref_color = ref_colors[index];
            if (ref_colors[index] in item.variable_color_codes){
               let variables = item.variable_color_codes[ref_color];
               // console.log(variables);
               for (var i = 0; i < variables.length; i++){
   
                  // Filtering the variables that don't go here. 
                  if (!valid.includes(variables[i])) continue;
   
                  let ref_string = basestring + "." + variables[i];
                  let display_string = text_replacer.getReportStringByReference(ref_string);
                  if (display_string.error != ""){
                     ret.error = "Parse Bulleted List, error while getting a reference string " + ref_string + " for color " + ref_color + ": " + display_string.error;
                     return ret;
                  }
                  itemized_list.push(display_string.value);
               }
            }
         }

         // // If no items are available for this color, then N/A is written. 
         // if (itemized_list.length == 0){
         //    itemized_list.push("N/A");
         // }
      }

      // Finally rendering the bulleted list. 
      const bulletedList = new BulletedList(pdf,title,itemized_list,bb.x,bb.y)
      bb = bulletedList.getBoundingBox();   

      // Saving the resulting bounding box. 
      ret.boundingBox = bb;   

      return ret;

   },

   parsePlainText: function (pdf,item,text_replacer){

      // Setting the text parameters. 
      pdf.setFontSize(this.TEXT_FONT_SIZE);
      pdf.setFont("Montserrat","Regular");
      pdf.setTextColor(Utils.Colors.MAIN_BLUE);

      // Output object.
      var ret = {};
      ret.error = "";

      let mandatory = ["id", "x", "y", "text", "effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Text: Missing keys " + missing.join(",");
         return ret;
      }      

      ret.id = item.id;      

      // Gettign the text.
      let text = text_replacer.reportString(item.text);
      if (text === false){
         ret.error = "Parse Text: Getting text - " + text_replacer.getError();
         return ret;
      }      

      // Breaking the text into multiple lines. 
      text = text.split("\n");
      let bb = pdf.getTextDimensions(text);

      let coordinates = this.computeItemBoundingBox(item,"Parse Text",true);
      if (coordinates.error != ""){
         ret.error = coordinates.error;
         return ret;
      }

      pdf.text(text,coordinates.x,coordinates.y,{baseline: "top"});
      ret.boundingBox = {};
      ret.boundingBox.x = coordinates.x;
      ret.boundingBox.y = coordinates.y;
      ret.boundingBox.w = bb.w;
      ret.boundingBox.h = bb.h;

      return ret;


   },

   parsePolygonGraph: function (pdf,item,text_replacer){
      
      // Output object.
      var ret = {};
      ret.error = "";

      let mandatory = ["id", "x", "y", "w", "levels", "separator", "values", "vertex_labels"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Polygon Graph: Missing keys " + missing.join(",");
         return ret;
      }      

      ret.id = item.id;         

      let coordinates = this.computeItemBoundingBox(item,"Parsing Polygon Graph",true);
      if (coordinates.error != ""){
         ret.error = coordinates.error;
         return ret;
      }

      // Computing the polygon side. 
      let polygon_side_l = item.w*item.effective_area.w;

      // Transforming the string for each of the vertex labels.
      let vertex_labels = [];
      for (var i = 0; i < item.vertex_labels.length; i++){
         let s = text_replacer.reportString(item.vertex_labels[i]);
         if (s === false){
            ret.error = "Parse Polygon Graph, vertex labels: " + text_replacer.getError();
            return ret;
         }
         vertex_labels.push(s);
      }

      // Two transformation in one. First the reference is transformed to it's report value, which will match one of the labels.
      // The the level index is found. If the level index is NOT found it is assumed that resulting level is equal to levels.length which is 
      // the center of the graph. 
      let vertex_values = [];
      for (var i = 0; i < item.values.length; i++){
         let v = text_replacer.reportValue(item.values[i]);
         if (v === false){
            ret.error = "Parse Polygon Graph, values: " + text_replacer.getError();
            return ret;
         }

         let level_index = item.levels.indexOf(v);
         if (level_index == -1) level_index = item.levels.length;

         vertex_values.push(level_index);

      }

      // Constructing the polygon graph.
      const polygon_graph_config = {};
      polygon_graph_config.l             = polygon_side_l
      polygon_graph_config.x             = coordinates.x
      polygon_graph_config.y             = coordinates.y
      polygon_graph_config.vertex_labels = vertex_labels
      polygon_graph_config.values        = vertex_values;
      polygon_graph_config.levels        = item.levels
      polygon_graph_config.separator     = item.separator;

      //console.log(polygon_graph_config);

      const polygon_graph = new PolygonGraph(pdf,polygon_graph_config);

      ret.boundingBox = {};
      ret.boundingBox.x = coordinates.x
      ret.boundingBox.y = coordinates.y
      ret.boundingBox.w = polygon_side_l
      ret.boundingBox.h = polygon_side_l
      return ret;

   },

   parseSideBySide4DotGraph: function(pdf,item,text_replacer){
      
      // Output object.
      var ret = {};
      ret.error = "";

      // In this case two level verification is necessary as there multiple keys associated with each of the graphs. 
      let mandatory = ["id", "left_graph", "right_graph" , "left_column_text", "right_column_text", "ylabel", "legend_data_set_0", "legend_data_set_1", "effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Side By Side 4Dot Graph: Missing keys " + missing.join(",");
         return ret;
      }      
      
      mandatory = ["x", "y", "w" , "h", "left_set", "right_set", "title"];
      missing = this.verifyAllKeys(item.left_graph,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Side By Side 4Dot Graph - Left Graph: Missing keys " + missing.join(",");
         return ret;
      }      

      mandatory = ["x", "y", "w" , "h", "left_set", "right_set", "title"];
      missing = this.verifyAllKeys(item.right_graph,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Side By Side 4Dot Graph - Right Graph: Missing keys " + missing.join(",");
         return ret;
      }      

      ret.id = item.id;         

      /// Replacing all texts. These are: the ylabel, the legend and the x labels.
      let texts_to_replace = ["left_column_text", "right_column_text", "ylabel", "legend_data_set_0", "legend_data_set_1"];
      for (var i = 0; i < texts_to_replace.length; i++){
         let s = text_replacer.reportString(item[texts_to_replace[i]]);
         if (s === false){
            ret.error = "Parse Side By Side 4Dot Graph, text " + texts_to_replace[i]  + ": " + text_replacer.getError();
            return ret;
         }
         item[texts_to_replace[i]] = s
      }

      /// Replacing the title texts. 
      let s = text_replacer.reportString(item.left_graph.title);
      if (s === false){
         ret.error = "Parse Side By Side 4Dot Graph, left graph title: " + text_replacer.getError();
         return ret;
      }
      item.left_graph.title = s

      s = text_replacer.reportString(item.right_graph.title);
      if (s === false){
         ret.error = "Parse Side By Side 4Dot Graph, right graph title: " + text_replacer.getError();
         return ret;
      }
      item.right_graph.title = s

      // Getting the values of values for the left graph, first the left set.
      for (var i = 0; i < item.left_graph.left_set.length; i++){
         let value = text_replacer.reportValue(item.left_graph.left_set[i]);
         if (value === false){
            ret.error = "Parse Side By Side 4Dot Graph: Getting left graph, left set values - " + text_replacer.getError();
            return ret;
         }   
         item.left_graph.left_set[i] = value;
      }

      // Getting the values of values for the left graph, second the right set.
      for (var i = 0; i < item.left_graph.right_set.length; i++){
         let value = text_replacer.reportValue(item.left_graph.right_set[i]);
         if (value === false){
            ret.error = "Parse Side By Side 4Dot Graph: Getting left graph, right set values - " + text_replacer.getError();
            return ret;
         }   
         item.left_graph.right_set[i] = value;
      }

      item.left_graph.effective_area = item.effective_area;
      let leftBB = this.computeItemBoundingBox(item.left_graph);
      if (leftBB.error != ""){
         ret.error = "Parse Side By Side 4Dot Graph on left graph bounding box - " + leftBB.error;
         return ret;
      }

      item.right_graph.effective_area = item.effective_area;
      let rightBB = this.computeItemBoundingBox(item.right_graph);
      if (rightBB.error != ""){
         ret.error = "Parse Side By Side 4Dot Graph on right graph bounding box - " + rightBB.error;
         return ret;
      }

      // Computing the final bounding box. 
      ret.boundingBox = {};
      ret.boundingBox.x = leftBB.x;
      ret.boundingBox.y = leftBB.y;
      ret.boundingBox.w = leftBB.w + rightBB.w;
      ret.boundingBox.h = leftBB.h;

      // In order to properly scale the graph, the maximum needs to be pre calculatlaed. 
      let graph_i = ["right_graph","left_graph"];
      let set_i  = ["right_set","left_set"];
      let max = 0;
      for (var i = 0; i < graph_i.length; i++){
         for (var j = 0; j < set_i.length; j++){
            let set = item[graph_i[i]][set_i[j]]
            if (max < set[0] + set[1]) max = set[0] + set[1];
            if (max < set[2] + set[3]) max = set[2] + set[3];
         }
      }


      // Creating the 4 do graph confiuration structure. The first object is to describe the left graph. 
      let config = {};

      config.legend = false; // When side by side the left 4 Dot graph should not have a legend.      
      config.leftColumnText  = item.left_column_text;
      config.rightColumnText = item.right_column_text
      config.yUnits = item.yunits
      config.legendValueType0 = item.legend_data_set_0
      config.legendValueType1 = item.legend_data_set_1
      config.hideyticks = true;
      config.ymax = max;

      if ("ndecimals" in item){
         config.ndecimals = item.ndecimals;
      }
      
      // The specific setting for the right graph. This is the control graph. It will set the scale for both. Also it doesn't have vertical labels. 
      config.title = item.right_graph.title;
      config.boundingRect = rightBB;
      config.leftSet = [ {value: item.right_graph.left_set[0], variance: item.right_graph.left_set[1]}, { value: item.right_graph.left_set[2], variance: item.right_graph.left_set[3]} ];
      config.rightSet = [ {value: item.right_graph.right_set[0], variance: item.right_graph.right_set[1]}, { value: item.right_graph.right_set[2], variance: item.right_graph.right_set[3]} ];

      const rightGraph = new FourPointGraph(pdf,config);
      rightGraph.render();

      config.yLabel = item.ylabel
      config.hideyticks = false;
      config.boundingRect = leftBB;
      config.title = item.left_graph.title;
      config.leftSet = [ {value: item.left_graph.left_set[0], variance: item.left_graph.left_set[1]}, { value: item.left_graph.left_set[2], variance: item.left_graph.left_set[3]} ];
      config.rightSet = [ {value: item.left_graph.right_set[0], variance: item.left_graph.right_set[1]}, { value: item.left_graph.right_set[2], variance: item.left_graph.right_set[3]} ];
      config.ymax = max

      const leftGraph = new FourPointGraph(pdf,config);
      leftGraph.render();

      // Rendering the centered legend. This needs to be called by the left most graph. 
      leftGraph.renderCenteredLegedBelowGraph(leftBB.w + rightBB.w);

      return ret;

   },

   parseSingle4DotGraph: function(pdf,item,text_replacer){
      
      // Output object.
      var ret = {};
      ret.error = "";

      // In this case two level verification is necessary as there multiple keys associated with each of the graphs. 
      let mandatory = ["id", "x", "y" , "w", "h", "left_column_text", "right_column_text", "ylabel", "legend_data_set_0", "legend_data_set_1", "data_set_left", "data_set_right" ,"yunits" ,"effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Single 4Dot Graph: Missing keys " + missing.join(",");
         return ret;
      }      
      ret.id = item.id;         

      /// Replacing all texts. These are: the ylabel, the legend and the x labels.
      let texts_to_replace = ["left_column_text", "right_column_text", "ylabel", "legend_data_set_0", "legend_data_set_1"];

      // Also the title if it exists, but that is optional.
      if ("title" in item){
         texts_to_replace.push("title");
      }

      for (var i = 0; i < texts_to_replace.length; i++){
         let s = text_replacer.reportString(item[texts_to_replace[i]]);
         if (s === false){
            ret.error = "Parse Single 4Dot Graph, text " + texts_to_replace[i]  + ": " + text_replacer.getError();
            return ret;
         }
         item[texts_to_replace[i]] = s
      }

      // Getting the values of values for the left graph, first the left set.
      for (var i = 0; i < item.data_set_left.length; i++){
         let value = text_replacer.reportValue(item.data_set_left[i]);
         if (value === false){
            ret.error = "Parse Single 4Dot Graph: Getting left data set values - " + text_replacer.getError();
            return ret;
         }   
         item.data_set_left[i] = value;
      }

      // Getting the values of values for the left graph, second the right set.
      for (var i = 0; i < item.data_set_right.length; i++){
         let value = text_replacer.reportValue(item.data_set_right[i]);
         if (value === false){
            ret.error = "Parse Single 4Dot Graph: Getting right data set values - " + text_replacer.getError();
            return ret;
         }   
         item.data_set_right[i] = value;
      }

      let bb = this.computeItemBoundingBox(item);
      if (bb.error != ""){
         ret.error = "Parse Single 4Dot Graph on left graph bounding box - " + bb.error;
         return ret;
      }

      // Computing the final bounding box. 
      ret.boundingBox = {};
      ret.boundingBox = bb;

      // Creating the 4 do graph confiuration structure. The first object is to describe the left graph. 
      let config = {};

      config.legend = true; 
      config.leftColumnText  = item.left_column_text;
      config.rightColumnText = item.right_column_text
      config.yUnits = item.yunits
      config.legendValueType0 = item.legend_data_set_0
      config.legendValueType1 = item.legend_data_set_1
      //config.hideyticks = true;
      config.yLabel = item.ylabel

      if ("ndecimals" in item){
         config.ndecimals = item.ndecimals;
      }

      if ("title" in item){
         config.title = item.title;
      }
      
      // The specific setting for the right graph. This is the control graph. It will set the scale for both. Also it doesn't have vertical labels. 
      config.boundingRect = bb;
      config.leftSet = [ {value: item.data_set_left[0], variance: item.data_set_left[1]}, { value: item.data_set_left[2], variance: item.data_set_left[3]} ];
      config.rightSet = [ {value: item.data_set_right[0], variance: item.data_set_right[1]}, { value: item.data_set_right[2], variance: item.data_set_right[3]} ];

      const graph = new FourPointGraph(pdf,config);
      graph.render();

      return ret;

   },

   parseFixationPlot: function (pdf,item,text_replacer){
      // Output object.
      var ret = {};
      ret.error = "";

      // In this case two level verification is necessary as there multiple keys associated with each of the graphs. 
      let mandatory = ["id", "x", "y" , "w", "h", "resolution", "fixations", "effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Fixation Graph: Missing keys " + missing.join(",");
         return ret;
      } 
      ret.id = item.id;       

      // For simplification the fixation drawing configuration is created here. So conditionals are only asked once. 
      let config = {};

      // Replacing texts if present. 
      if ("title" in item){
         let s = text_replacer.reportString(item.title);
         if (s === false){
            ret.error = "Parse Fixation Graph. Title :" + text_replacer.getError();
            return ret;
         }
        config.title = s
      }

      if ("label" in item){
         let s = text_replacer.reportString(item.label);
         if (s === false){
            ret.error = "Parse Fixation Graph. label :" + text_replacer.getError();
            return ret;
         }
        config.label = s
      }

      // Computing the bounding box.
      let bb = this.computeItemBoundingBox(item,"Parse Fixation Graph");
      if (bb.error != ""){
         ret.error = "Parse Fixation Graph. On computing Bounding Box: " + ret.error;
         return ret;
      }
      config.boundingRect = bb;

      // Getting the fixations.
      let fixations = text_replacer.reportValue(item.fixations);
      if (fixations === false){
         ret.error = "Parse Fixation Graph. Getting fixations: " + text_replacer.getError();
         return ret;
      }
      config.fixations = fixations;

      // Getting the resolution.
      let resolution = text_replacer.reportValue(item.resolution);
      if (resolution === false){
         ret.error = "Parse Fixation Graph. Getting fixations: " + text_replacer.getError();
         return ret;
      }
      config.resolution = resolution;    
      
      // checking the fix plotting type.
      if ("binding" in item){
         config.binding = item.binding;
      }
      else if ("gonogo" in item){
         config.gonogo = item.gonogo
      }
      else if ("nbackrt" in item){
         config.nback = item.nbackrt;
      }
      else{
         ret.error = "Parse Fixation Graph: Could not find a valid fixation graph type.";
         return ret;
      }

      // Checking if it is necessary to enable legacy mode.
      if ("legacy" in item){
         //console.log("Item legacy is");
         //console.log(item.legacy);
         if (item.legacy) config.enable_legacy_scaling = true;
      }
      
      // Finally fixation is drawn. 
      const fixDrawer = new FixationDrawer(pdf);
      //console.log(config);
      fixDrawer.render(config);

      return ret;

   },

   parsePresumptiveDiagnosis: function (pdf,item,text_replacer){
      // Output object.
      var ret = {};
      ret.error = "";

      // In this case two level verification is necessary as there multiple keys associated with each of the graphs. 
      let mandatory = ["id", "x", "y" , "w", "h", "right_title", "left_title", "value", "text_index", "text_base" ,"separator", "effective_area"];
      let missing = this.verifyAllKeys(item,mandatory);
      if (missing.length > 0){
         ret.error = "Parse Presumptive Diag Box Missing keys " + missing.join(",");
         return ret;
      } 
      ret.id = item.id;       

      // Computing the bounding box. 
      let bb = this.computeItemBoundingBox(item,"Parse Presumptive Diag Box");
      if (bb.error != ""){
         ret.error = bb.error;
         return ret;
      }

      ret.boundingBox = bb;

      // We need to get the text index. 
      let v = text_replacer.reportValue(item.text_index);
      //console.log("Presumptive diagnosis value is: " + v)
      if (v === false){
         ret.error = "Parse Presumptive Diag Box, getting the text index: " + text_replacer.getError();
         return ret;
      }

      // So the text to replaces is composed of the text_base plus the index. Concateneated by a . 
      item.text = "#" + item.text_base + "." + v + "#";

      // Getting all texts. 
      let texts_to_replace = ["right_title", "left_title", "text"];
      for (var i = 0; i < texts_to_replace.length; i++){
         //console.log(item[texts_to_replace[i]])
         let s = text_replacer.reportString(item[texts_to_replace[i]]);
         if (s === false){
            ret.error = "Parse Presumptive Diag Box, text " + texts_to_replace[i]  + ": " + text_replacer.getError();
            return ret;
         }
         item[texts_to_replace[i]] = s
      }      

      // Getting the value. 
      v = text_replacer.reportValue(item.value);
      if (v === false){
         ret.error = "Parse Presumptive Diag Box, getting the value: " + text_replacer.getError();
      }

      let config = {};
      config.boundingBox = bb;
      config.left_title = item.left_title
      config.right_title = item.right_title
      config.value = Math.round(v) + "%"
      config.text = item.text
      config.separator = item.separator

      const pbox = new PresumptiveDiagnosisBox(pdf,config);

      return ret;

   },

   /**
    * Computes the index for the presumptive diagnosis string. Each variable needs to have its corresponding
    * color code previously computed. This color sequence (in an order provided by the variables field of the pdiag
    * field in layout) results in a index which is then used for the language object. 
    * @param {Object} [layout] - General description of the postion and graphical components of a report. Among other thigs, it contains the lookup table for pressumptive diagnosis.
    * @param {Object} [report] - Report generated values. 
    * @returns An object {index: number, error: string}. If all goes well index is the index of the presumptive diagnosis string and error is empty. Otherwise index is -1 and error contains the error message
    */

   computePresumptiveDiagnosis: function (layout,report){

      let ret = {};
      ret.error = "";
      ret.index = -1;

      let varlist = layout.pdiag.variables;
      let index = layout.pdiag.text_index;
      //console.log(layout.pdiag)
      for (var i = 0; i < varlist.length; i++){
         
         // The color assinged to each variable is in the subfield 'color' of a field named after the variable itself. 
         if (!(varlist[i] in report.indexes["color"])){
            ret.error = "PDiag Index Calc: Unknonw variable " + varlist[i] + " while computing pdiag string";
            //console.log(report.indexes);
            return ret;
         }
         let color_name = report.indexes["color"][varlist[i]];

         //console.log("PDIAG Color for " + varlist[i] + " is " + color_name)
         //console.log(JSON.stringify(index));

         if (typeof(index) === "object"){
            if (color_name in index){
               index = index[color_name]; // This recursive search should leave only the index after the final de reference. 
            }
            else{
               ret.error = "PDiag Index Calc: At variable " + varlist[i] + " index " + i + " of " 
               + (varlist.length-1) + " current object does contain key name " + color_name;   
               return ret;
            }
         }
         else{
            ret.error = "PDiag Index Calc: At variable " + varlist[i] + " index " + i + " of " 
            + (varlist.length-1) + " it's not an object but " + typeof(index);
            return ret;
         }
         
      }

      // If we got here there were no errors. 
      //console.log("Returning index: " + index);
      ret.index = index;

      return ret;

   },

   /**
    * Computes the polygon and color indexes which are required for polygon graphs and result bars. 
    */

   computeIndexes:  function(layout,report){
      
      // Creating the indexs object. 
      report.indexes = {};
      
      // Value keys in the categories object should be the names of the variables in the report object 
      // The category is the label: the color or the polygon graph value. skip_sd is a special category that needs to be ignored. 
      for (variable_name in layout.categories) {

         let available_categories = layout.categories[variable_name];

         if (!(variable_name in report)){
            return "Value key " + variable_name + " is not a report variable";
         }

         let report_value = report[variable_name];

         for (category in available_categories){

            if (category == "skip_sd") continue;

            // Each category is created in the index object. 
            if (!(category in report.indexes)){
               report.indexes[category] = {};
            }

            let category_array = available_categories[category];

            // Categorizing the value itself. 
            let segment_classifier = new SegmentClassifier(category_array);

            if (segment_classifier.getErrors().length > 0){
               return segment_classifier.getErrors().join("\n");
            }

            let label = segment_classifier.categorize(report_value);
            if (label == ""){
               return "Could not find the proper value segment for value " + report_value + " for variable " + variable_name + " and category: " + category;
            }

            // Each category has a value for each variable. 
            // console.log("Assigning to category " + category + " with variable name " + variable_name + " the label " + label);
            report.indexes[category][variable_name] = label;

         }

      }

      return "";

   }

}

module.exports = LayoutParser;