var fs = require('fs');
const { runInThisContext } = require('vm');

var Colors = {
   MAIN_BLUE:   "#0d2543",
   
   // Generic use colors.
   BLACK: "#000000",
   WHITE: "#ffffff",

   // Dark Text Color
   DARK_TEXT_COLOR: "#4b4b4b",

   // Line graph axis label color
   LINEGRAPH_AXIS_LABEL: "#7f7f7f",

   // Result Segment Text Color
   RESULT_TEXT_COLOR: "#666666",
   
   // The code colors.
   CODE_BLUE:   "#18557f",
   CODE_GREEN:  "#479a49",
   CODE_YELLOW: "#dfaf2c",
   CODE_RED:    "#cc3a27",

   // Fixation color.
   FIXATION_COLOR: "#a6217f",

   // Polygon Graph colors
   POLYGRAPH_LINE : "#bfbfbf",
   POLYGRAPH_FILL : "#409896",
   POLYGRAPH_TEXT : "#666666",

   // Go No Go Arrow Colors. 
   GONOGO_GREEN: "#409896",
   GONOGO_RED: "#a7397f",

   // Graph colors
   GRAPH_BACKGROUND: "#f7f7f7",
   GRAPH_PURPLE: "#a73a7f",
   GRAPH_BLUE: "#3f9796"

}

var Utils = {
   bas64EncodeFile: function (file){
      // read binary data
      var bitmap = fs.readFileSync(file);
      // convert binary data to base64 encoded string
      return Buffer.from(bitmap).toString('base64');  
   },

   /**
    * @brief Loads all fonts in the enconded fonts directory. The format requires the name to be family_name-style-(something or nothing).something. 
    * @param {jsPDF instance} pdf 
    * 
    */
   loadFonts: function(pdf){

      var font_dir = "./resources/encoded_fonts";

      var font_files = fs.readdirSync(font_dir);
      for (i in font_files){
         var font_file = font_files[i];
         var font_data = fs.readFileSync(font_dir + "/" + font_file,{"encoding": "UTF-8"});
         var name_parts = font_file.split(".");
         var vfsFileName = name_parts[0] + ".ttf";
         var font_name_parts = name_parts[0].split("-");
         var family = font_name_parts[0];
         var stylization = font_name_parts[1];
         pdf.addFileToVFS(vfsFileName,font_data);
         //console.log("Adding " + family + " style " + stylization);
         pdf.addFont(vfsFileName,family,stylization);         
      }
      //console.log(pdf.getFontList())
   }

};

/**
 * Maps a origin range to a target range, linearly
 */

class LinearMapper {

   #m
   #b

   constructor(origin_min, origin_max, target_min, target_max){
      this.#m = (target_max - target_min)/(origin_max - origin_min);
      this.#b = target_max - this.#m*origin_max;
   }

   getMappedValue(v){
      return this.#m*v + this.#b
   }

}

module.exports.Utils = Utils
module.exports.Colors = Colors
module.exports.LinearMapper = LinearMapper