#include "calibrationmanager.h"

CalibrationManager::CalibrationManager(QObject *parent) : QObject(parent)
{

    connect(&calibration2DTargetControl,&CalibrationTargets::calibrationPointStatus,this,&CalibrationManager::onCalibrationPointStatus);
    connect(&calibration2DTargetControl,&CalibrationTargets::newAnimationFrame,this,&CalibrationManager::onNewAnimationFrame);
    connect(&waitToGatherTimer,&QTimer::timeout,this,&CalibrationManager::onWaitToDataGather);
    enableSendAnimationFrames = false;

}

////////////////////// Configure and Starte Calibration //////////////////
void CalibrationManager::startCalibration(qint32 width,
                                          qint32 height,
                                          bool mode3D,
                                          const QVariantMap &calib_valid_params,
                                          const QString coefficient_file_name){

    calibrationMode3D = mode3D;
    coefficientFileName = coefficient_file_name;
    calibration_wait_time = calib_valid_params[VMDC::CalibrationAttemptFields::CALIBRATION_POINT_WAITTIME].toInt();
    calibration_gather_time = calib_valid_params[VMDC::CalibrationAttemptFields::CALIBRATION_POINT_GATHERTIME].toInt();
    numberOfCalibrationPoints = calib_valid_params[VMDC::CalibrationConfigurationFields::NUMBER_OF_CALIBRAION_POINTS].toInt();
    calibrationValidationData = calib_valid_params;

    isCalibrated = false;

    enableSendAnimationFrames = false;
    currentCalibrationPointIndex = 0;
    //isDataGatheringEnabled = false;
    isDataGatheringEnabled = true; // We only stop data gathering when the calibration is finished.

    if (DBUGBOOL(Debug::Options::LOAD_PREFIX_CALIB)){
        if (mode3D){            
            if (debugLoadFixed3DCalibrationParameters()) return;
        }
        else {
            if (debugLoadFixed2DCalibrationParameters()) return;
        }
    }

    // We need to initialize the 2D target control no matther the calibration type. The list generated by it is used the validation screen,
    // regardless of calibration type.
    calibration2DTargetControl.initialize(width,height);
    // Get where the calibration centres are located. The second function actually configures the number of calibration points correcty. The list in only used in 2D Mode.
    QList<QPointF> calibrationPoints = calibration2DTargetControl.setupCalibrationSequence(numberOfCalibrationPoints,calibration_gather_time + calibration_wait_time);

    // If we got here, this is a normal calibration.
    if (calibrationMode3D){
        // We need to send a packet to the render server to start the 3D Calibration.
        renderServerPacket.resetForRX();
        renderServerPacket.setPacketType(RenderServerPacketType::TYPE_CALIB_CONTROL);
        renderServerPacket.setPayloadField(CalibrationControlPacketFields::COMMAND,CalibrationControlCommands::CMD_SETUP);
        renderServerPacket.setPayloadField(CalibrationControlPacketFields::GATHER_TIME,calibration_gather_time);
        renderServerPacket.setPayloadField(CalibrationControlPacketFields::MOVE_TIME,calibration_wait_time);
        renderServerPacket.setPayloadField(CalibrationControlPacketFields::N_CALIB_POINTS,numberOfCalibrationPoints);
        emit CalibrationManager::newPacketAvailable();
    }
    else {
        // Setup the correction coefficient computation for the 2D calibration
        correctionCoefficients.configureFor2DCoefficientComputation(calibrationPoints);
        // Enabling sending the animation frame.
        enableSendAnimationFrames = true;
        // And actually start the calibration
        calibration2DTargetControl.calibrationAnimationControl(true);
    }

}

////////////////////// Interface Functions //////////////////
RenderServerPacket CalibrationManager::getRenderServerPacket() const {
    return renderServerPacket;
}

QVariantMap CalibrationManager::getCalibrationAttemptData() const {
    return calibrationValidation.getCalibrationAttemptData();
}

QVariantMap CalibrationManager::getCalibrationConfigurationParameters() const {
    return calibrationValidation.getCalibrationConfigurationData();
}

QString CalibrationManager::getRecommendedEye() const {
    return calibrationValidation.getRecommendedEye();
}

QString CalibrationManager::getCalibrationValidationReport() const {
    return calibrationValidation.getValidationReport();
}

bool CalibrationManager::isCalibrationCompleted() const{
    return isCalibrated;
}

void CalibrationManager::resetCalibrationCompleted(){
    isCalibrated = false;
}

bool CalibrationManager::requires2DCalibrationDataPointSamples() const {
    return isDataGatheringEnabled;
}

////////////////////// Add calibration data to target and finalize the calibration process //////////////////
void CalibrationManager::addEyeDataToCalibrationPoint(float xl, float xr, float yl, float yr, float zl, float zr){
    EyeTrackerData eid;
    eid.setXL(static_cast<qreal>(xl));
    eid.setXR(static_cast<qreal>(xr));
    eid.setYL(static_cast<qreal>(yl));
    eid.setYR(static_cast<qreal>(yr));
    eid.setZL(static_cast<qreal>(zl));
    eid.setZR(static_cast<qreal>(zr));
    //qDebug() << "   Storing" << eid.toString(true) << " for calibration point " << currentCalibrationPointIndex;
    correctionCoefficients.addPointForCoefficientComputation(eid,currentCalibrationPointIndex);
}

void CalibrationManager::finalizeCalibrationProcess(qint32 code, bool sendCalibrationCoefficientsToServer){

    enableSendAnimationFrames = false;

    // We compute the corrections.
    if (!correctionCoefficients.computeCoefficients()){
        StaticThreadLogger::error("CalibrationManager::finalizeCalibrationProcess","Failed in computing the correction coefficients. Reason: " + correctionCoefficients.getLastError());
        code = CALIBRATION_FAILED;
    }

    // We now configure everthing to get the calibration report.
    calibrationValidation.configureValidation(calibrationValidationData,
                                              nonNormalizedTargetVectors,validationRadious,
                                              calibration2DTargetControl.getCalibrationTargetCorners(),
                                              calibration2DTargetControl.getCalibrationTargetDiameter(),
                                              calibrationMode3D);

    // And we actually generate it.
    bool wasSuccessfull = calibrationValidation.generateCalibrationReport(correctionCoefficients);

    if (wasSuccessfull && sendCalibrationCoefficientsToServer){
        // We now send the coefficients back to the remote render server so they can be used.
        sendCalibrationCoefficientPacket();
    }

    // We save the coefficient file, only if the calibration is successful.
    if (code == CALIBRATION_SUCCESSFUL){
        if (coefficientFileName != ""){
            correctionCoefficients.saveCalibrationCoefficients(coefficientFileName);
        }
    }

    emit CalibrationManager::calibrationDone(code);
}

////////////////////// 2D Calibration Functions //////////////////
void CalibrationManager::onWaitToDataGather(){
    //isDataGatheringEnabled = true;
    correctionCoefficients.setStartPointForValidCalibrationRawData(currentCalibrationPointIndex);
    waitToGatherTimer.stop();
}


void CalibrationManager::onNewAnimationFrame(){
    if (!enableSendAnimationFrames) return;
    renderServerPacket = calibration2DTargetControl.getCurrentCalibrationAnimationFrame().render();
    emit CalibrationManager::newPacketAvailable();
}

void CalibrationManager::onCalibrationPointStatus(qint32 whichCalibrationPoint, bool isMoving){

    QString str = QString::number(whichCalibrationPoint);

    if (isMoving) str = str + ". Is Moving: true";
    else str = str + ". Is Moving: false";
    str = str + ". Number of Calibration Points: " + QString::number(numberOfCalibrationPoints);

    // StaticThreadLogger::log("CalibrationLeastSquares::onCalibrationPointStatus","Calibration Point Update to: " + str);

    if (isMoving){
        // isDataGatheringEnabled = false;
        currentCalibrationPointIndex++;
        //if (whichCalibrationPoint == (numberOfCalibrationPoints-1)){
        if (currentCalibrationPointIndex == numberOfCalibrationPoints){
            // We've reached the end.
            calibration2DTargetControl.calibrationAnimationControl(false);
            isDataGatheringEnabled = false; // Calibration done.
            finalizeCalibrationProcess(CALIBRATION_SUCCESSFUL,false);
        }
    }
    else {
        waitToGatherTimer.start(calibration_wait_time);
        //currentCalibrationPointIndex = whichCalibrationPoint;
    }

    // qDebug() << "Calibration Point Status Update" <<  whichCalibrationPoint << isMoving << " Current Calibration point " << currentCalibrationPointIndex;

}

EyeTrackerData CalibrationManager::correct2DData(EyeTrackerData input){
    return correctionCoefficients.computeCorrections(input);
}

////////////////////// 3D Calibration Functions //////////////////
void CalibrationManager::process3DCalibrationEyeTrackingData(const RenderServerPacket &calibrationData){

    nonNormalizedTargetVectors.clear();
    validationRadious = calibrationData.getPayloadField(CalibrationControlPacketFields::VALIDATION_R).toReal();

    StaticThreadLogger::log("CalibrationManager::process3DCalibrationEyeTrackingData","Setting the validation radious to " + QString::number(validationRadious));

    QVariantList tx = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIBRATION_TARGETS_X).toList();
    QVariantList ty = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIBRATION_TARGETS_Y).toList();
    QVariantList tz = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIBRATION_TARGETS_Z).toList();

    // Creating the target vectors.
    qsizetype N = tx.size();

    QVariantList start_index_list = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIB_DATA_START_IND).toList();

    if (start_index_list.size() != N){
        StaticThreadLogger::error("CalibrationManager::process3DCalibrationEyeTrackingData","The number start indexes for calibration (" + QString::number(start_index_list.size()) + ") differs from the number of points " + QString::number(N));
        start_index_list.clear();
        for (qint32 i = 0; i < N; i++){
            start_index_list << 0;
        }
    }

    // List starts at 1 as the first target is the middle dummy target.
    for (qsizetype i = 1; i < N; i++){
        QVector3D vec;
        vec.setX(tx.at(i).toFloat());
        vec.setY(ty.at(i).toFloat());
        vec.setZ(tz.at(i).toFloat());
        nonNormalizedTargetVectors << vec;
    }

    // Configuring the coefficient correction computation for 3D.
    correctionCoefficients.configureFor3DCoefficientComputation(nonNormalizedTargetVectors,validationRadious);

    // Now we add all the data.
    QVariantList rx = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIB_DATA_RX).toList();
    QVariantList ry = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIB_DATA_RY).toList();
    QVariantList rz = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIB_DATA_RZ).toList();
    QVariantList lx = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIB_DATA_LX).toList();
    QVariantList ly = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIB_DATA_LY).toList();
    QVariantList lz = calibrationData.getPayloadField(CalibrationControlPacketFields::CALIB_DATA_LZ).toList();

    for (qsizetype i = 1; i < N; i++){

        QVariantList cdxr = rx.value(i).toList();
        QVariantList cdxl = lx.value(i).toList();
        QVariantList cdyr = ry.value(i).toList();
        QVariantList cdyl = ly.value(i).toList();
        QVariantList cdzr = rz.value(i).toList();
        QVariantList cdzl = lz.value(i).toList();

        qsizetype M = cdxr.size(); // They should all be the same size.
        currentCalibrationPointIndex = static_cast<qint32>(i)-1;

        qint32 start_index = start_index_list.value(i).toInt();
        if (start_index == -1){
            StaticThreadLogger::error("CalibrationManager::process3DCalibrationEyeTrackingData","The calibration start index for calibration point  " + QString::number(i) + " has not been set");
            start_index = 0;
        }
        else if (start_index >= (M-1)) {
            StaticThreadLogger::error("CalibrationManager::process3DCalibrationEyeTrackingData","The calibration start index for calibration point  " + QString::number(i) + " has been set to "
                                      + QString::number(start_index) + " however the number of data points is " + QString::number(M));
            start_index = 0;
        }

        //qDebug() << "DATA FOR TARGET VECTOR " << nonNormalizedTargetVectors.at(currentCalibrationPointIndex);

        // Adding ieach of the sample to the coefficients using the convenience funtion.
        for (qsizetype j = 0; j < M; j++){
            addEyeDataToCalibrationPoint(cdxl.at(j).toFloat(),cdxr.at(j).toFloat(),
                                         cdyl.at(j).toFloat(),cdyr.at(j).toFloat(),
                                         cdzl.at(j).toFloat(),cdzr.at(j).toFloat());

            if (j == start_index){
                // Setting the cuttoff index for this target.
                correctionCoefficients.setStartPointForValidCalibrationRawData(currentCalibrationPointIndex);
            }
        }

    }

    // Now that the data we can finalize the calibration process.
    finalizeCalibrationProcess(CALIBRATION_SUCCESSFUL,true);

}

void CalibrationManager::sendCalibrationCoefficientPacket(){
    renderServerPacket.resetForRX();
    renderServerPacket.setPacketType(RenderServerPacketType::TYPE_CALIB_CONTROL);
    renderServerPacket.setPayloadField(CalibrationControlPacketFields::COMMAND,CalibrationControlCommands::CMD_COEFFICIENTS);
    renderServerPacket.setPayloadField(CalibrationControlPacketFields::COEFFS_l,correctionCoefficients.getCalibrationControlPacketCompatibleMap(true));
    renderServerPacket.setPayloadField(CalibrationControlPacketFields::COEFFS_R,correctionCoefficients.getCalibrationControlPacketCompatibleMap(false));
    emit CalibrationManager::newPacketAvailable();
}

////////////////////// DEBUG LOAD FUNCTIONS //////////////////
void CalibrationManager::debugSaveCalibrationValidationData(const QString &filename){
    calibrationValidation.saveToJSONFile(filename);
}

bool CalibrationManager::debugLoadFixed3DCalibrationParameters() {

    QFile file(":/debug_files/3dCalibData.json");
    if (!file.open(QFile::ReadOnly)){
        qDebug() << "Failed in loading DEBUG 3D File";
        return false;
    }
    QTextStream reader(&file);
    QString fixed_dat = reader.readAll();
    file.close();

    calibrationValidation.setDataFromString(fixed_dat);

    QString matrix = "0.8676431,0.0202019159, -0.00122752122,-0.06256262\n\
-0.006712373,0.996084332,-0.171135783,0.132956\n\
0.08176654,-0.0281286743,0.822351158,0.170508042\n\
0.9300998,-0.008620117,-0.238664374,0.224052832\n\
0.008516804,1.01506889,-0.08259078,0.0297427\n\
-0.003751203,0.003546328,0.9096183,0.08610141";

    if (!correctionCoefficients.loadFromTextMatrix(matrix)) return false;

    // Sending the calibration packet.
    sendCalibrationCoefficientPacket();

    emit CalibrationManager::calibrationDone(CALIBRATION_SUCCESSFUL);

    isDataGatheringEnabled = false;

    return true;
}

bool CalibrationManager::debugLoadFixed2DCalibrationParameters(){
    QFile file(":/debug_files/2dCalibData.json");
    if (!file.open(QFile::ReadOnly)){
        qDebug() << "Failed in loading DEBUG 2D File";
        return false;
    }
    QTextStream reader(&file);
    QString fixed_dat = reader.readAll();
    file.close();

    //qDebug() << "Setting data";

    calibrationValidation.setDataFromString(fixed_dat);

    QString matrix = "-1921.2350476661336,1103.633319863327\n\
    -2032.2447889194718,1279.4145830880336\n\
    -2063.753443167157,1245.5719666971615\n\
    -2095.759211028236,1337.245378319595";

    //qDebug() << "Loading from matrix 2D Parameters";

    if (!correctionCoefficients.loadFromTextMatrix(matrix)) return false;

    //qDebug() << "Emitting calibration successfull";

    isDataGatheringEnabled = false;

    emit CalibrationManager::calibrationDone(CALIBRATION_SUCCESSFUL);

    return true;

}
